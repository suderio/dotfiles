#!/usr/bin/env bb

(require '[babashka.process :refer [shell process]]
          '[babashka.fs :as fs]
          '[clojure.string :as str])
;;
;; Reference: https://cisofy.com/lynis/controls/<CODE-NNNN>/

;; --- Configura√ß√£o do Registro ---
;; Aqui unificamos a descri√ß√£o e o mapeamento.
;; As fun√ß√µes (:fix e :check) ser√£o resolvidas dinamicamente baseadas na chave.
(def registry
  {"boot-5264"           {:desc "An√°lise de seguran√ßa dos servi√ßos systemd"}
   "krnl-5820"           {:desc "Desativa core dumps via limits.conf"}
   "auth-9230"           {:desc "Configura hashing rounds para senhas"}
   "auth-9262"           {:desc "Instala m√≥dulo PAM de for√ßa de senha"}
   "auth-9282"           {:desc "Define data de expira√ß√£o para contas"}
   "auth-9286"           {:desc "Configura idade m√≠nima/m√°xima de senha"}
   "auth-9328"           {:desc "Define umask padr√£o mais restrito (027)"}
   "file-6354"           {:desc "Verifica arquivos antigos em /tmp"}
   "usb-1000"            {:desc "Desativa armazenamento USB"}
   "usb-1000_restore"    {:desc "Reativa armazenamento USB"}
   "strg-1846"           {:desc "Desativa suporte a FireWire"}
   "name-4028"           {:desc "Verifica e ajusta dom√≠nio DNS do sistema"}
   "pkgs-7312"           {:desc "Atualiza pacotes (rolling updates)"}
   "pkgs-7320"           {:desc "Instala `arch-audit` para vulnerabilidades"}
   "netw-3200"           {:desc "Desativa protocolos desnecess√°rios (dccp, etc)"}
   "unblock-net_protocols" {:desc "Reativa protocolos desativados"}
   "ssh-7408"            {:desc "Aplica hardening na configura√ß√£o do SSH"}
   "php-2372"            {:desc "Desativa expose_php no php.ini"}
   "php-2376"            {:desc "Desativa allow_url_fopen no php.ini"}
   "logg-2146"           {:desc "Configura rota√ß√£o de logs em /var/log"}
   "bann-7126"           {:desc "Adiciona banner legal ao /etc/issue e issue.net"}
   "acct-9622"           {:desc "Ativa process accounting (accton)"}
   "acct-9626"           {:desc "Ativa coleta com sysstat (sar, iostat)"}
   "acct-9628"           {:desc "Ativa auditd e regras b√°sicas"}
   "acct-report"         {:desc "Relat√≥rio de contabilidade de processos"}
   "audit-report"        {:desc "Relat√≥rio dos eventos de auditd"}
   "time-3104"           {:desc "Ativa sincroniza√ß√£o com systemd-timesyncd"}
   "cryp-7902"           {:desc "Verifica expira√ß√£o de certificados SSL"}
   "fint-4350"           {:desc "Instala AIDE e inicializa integridade de arquivos"}
   "fint-schedule"       {:desc "Agendamento de verifica√ß√£o do AIDE"}
   "tool-5002"           {:desc "Verifica presen√ßa de ferramentas de automa√ß√£o"}
   "file-7524"           {:desc "Corrige permiss√µes inseguras de arquivos"}
   "krnl-6000"           {:desc "Aplica sysctl seguros e gera backup"}
   "krnl-6000_restore"   {:desc "Restaura sysctl a partir de backup salvo"}
   "hrdn-7222"           {:desc "Restringe uso de compiladores por usu√°rios"}
   "hrdn-7222_prune"     {:desc "Remove compiladores n√£o autorizados"}
   "hrdn-7230"           {:desc "Instala e agenda scanner com rkhunter"}})

;; --- Helpers de Resolu√ß√£o ---

(defn to-symbol
  "Converte 'boot_5264' em symbol 'boot-5264' (ou 'boot-5264-check')."
  [action-name suffix]
  (let [kebab-name (str/replace action-name "_" "-")
        full-name (if suffix (str kebab-name "-" suffix) kebab-name)]
    (symbol full-name)))

(defn resolve-fn
  "Tenta encontrar a fun√ß√£o no namespace atual."
  [action-name type]
  (let [func-sym (to-symbol action-name (when (= type :check) "check"))
        f (resolve func-sym)]
    (if f
      f
      (throw (ex-info (str "Fun√ß√£o n√£o implementada: " func-sym) {:fn func-sym})))))

(defn print-help []
  (println "\nüîê Arch Linux Hardening Script (Babashka Port)")
  (println "Uso: hardening <a√ß√£o> [--dry-run] [--auto] [--check-only]\n")
  (println "A√ß√µes dispon√≠veis:")
  (doseq [k (sort (keys registry))]
    (println (format "  %-25s %s" k (get-in registry [k :desc]))))
  (println "\nUse --dry-run para simular e --auto para execu√ß√£o sem perguntas.")
  (System/exit 0))

;; --- Fun√ß√£o Main ---

(defn -main [& args]
  (let [args-set (set args)
        ;; Identifica a a√ß√£o (o primeiro argumento que n√£o come√ßa com --)
        action (first (remove #(str/starts-with? % "--") args))

        options {:dry-run    (contains? args-set "--dry-run")
                 :auto       (contains? args-set "--auto")
                 :check-only (contains? args-set "--check-only")}]

    (cond
      (or (nil? action)
          (contains? args-set "--help")
          (contains? args-set "-h"))
      (print-help)

      (not (contains? registry action))
      (do
        (println (str "‚ùå A√ß√£o desconhecida: " action))
        (println "Use --help para listar as a√ß√µes dispon√≠veis.")
        (System/exit 1))

      :else
      (try
        (println (str "üöÄ Iniciando m√≥dulo: " action))

        ;; L√≥gica da nova arquitetura:
        ;; 1. Resolvemos as fun√ß√µes baseadas no nome da string (snake -> kebab)
        (let [fn-fix   (resolve-fn action :fix)
              fn-check (resolve-fn action :check)]

          ;; Se o usu√°rio pediu apenas check, ou se estamos rodando o fix normal
          ;; Aqui voc√™ pode decidir a l√≥gica. Por exemplo:
          ;; O padr√£o do script Perl era rodar a corre√ß√£o.

          (if (:check-only options)
            (if (fn-check options)
              (println "‚úÖ Verifica√ß√£o OK")
              (println "‚ö†Ô∏è  Verifica√ß√£o FALHOU (A√ß√£o necess√°ria)"))

            ;; Fluxo padr√£o: Executar a corre√ß√£o
            (fn-fix options)))

       (catch Exception e
         (println (str "\nüî¥ Erro cr√≠tico: " (.getMessage e)))
         ;; (println (ex-data e)) ;; Descomente para debug
         (System/exit 1))))))


; BOOT-5264: Consider hardening system services
; Run '/usr/bin/systemd-analyze security SERVICE' for each service

(defn get-running-services
  "Retorna uma lista de nomes de servi√ßos ativos (ex: sshd.service)."
  []
  (let [res (shell {:out :string} "systemctl list-units --type=service --state=running --no-legend --plain")
        lines (str/split-lines (:out res))]
    (->> lines
         (map #(first (str/split % #"\s+")))        ;; Pega a primeira coluna
         (filter #(str/ends-with? % ".service"))))) ;; Garante que √© .service

(defn boot-5264-check [_opts]
  (println "üîç [BOOT-5264] Verificando pontua√ß√£o de seguran√ßa global...")

  ;; systemd-analyze security sem argumentos lista todos os servi√ßos com score
  ;; Formato: UNIT EXPOSURE PREDICATE HAPPY
  (let [res (shell {:out :string :continue true} "systemd-analyze security --no-pager")
        lines (drop 1 (str/split-lines (:out res))) ;; Remove cabe√ßalho
        threshold 5.0] ;; Defina seu limiar de toler√¢ncia aqui

    (if (not= 0 (:exit res))
      (do
        (println "‚ö†Ô∏è  systemd-analyze n√£o encontrado ou falhou.")
        false) ;; Falha se n√£o conseguir rodar

      (let [risky-services (->> lines
                                (map (fn [line]
                                       (let [parts (str/split (str/trim line) #"\s+")
                                             unit  (first parts)
                                             score (try (Double/parseDouble (nth parts 1))
                                                        (catch Exception _ 0.0))]
                                         {:unit unit :score score})))
                                (filter #(> (:score %) threshold)))]

        (if (seq risky-services)
          (do
            (println (str "‚ùå Encontrados " (count risky-services) " servi√ßos com exposi√ß√£o > " threshold))
            ;; Retorna false para indicar que a verifica√ß√£o falhou e o 'fix' deve rodar
            false)
          (do
            (println "‚úÖ Todos os servi√ßos est√£o dentro dos limites de seguran√ßa.")
            true))))))

(defn boot-5264 [opts]
  (println "\n[BOOT-5264] Iniciando an√°lise detalhada (Hardening System Services)...")

  (let [services (get-running-services)]
    (println (str "‚ÑπÔ∏è  Servi√ßos identificados: " (count services)))

    (doseq [service services]
      (println (str "\nüîç Analisando seguran√ßa detalhada de: " service))
      ;; Aqui replicamos o comportamento do Perl: rodar a an√°lise detalhada por servi√ßo
      ;; Usamos :continue true pois alguns servi√ßos podem dar erro de permiss√£o ou n√£o suportar an√°lise
      (let [res (shell {:out :string :continue true} "systemd-analyze" "security" service)]
        (println (:out res)))))

  (println "\n[BOOT-5264] An√°lise conclu√≠da.")
  (println "üëâ A√ß√£o recomendada: Revise os servi√ßos acima com pontua√ß√£o 'UNSAFE' e adicione diretivas de sandboxing (ex: ProtectSystem, PrivateTmp) nos unit files."))


; KRNL-5820: Disable core dumps via limits.conf
; https://linux-audit.com/software/understand-and-configure-core-dumps-work-on-linux/
(def limits-conf "/etc/security/limits.conf")

;; Strings exatas para escrita (mantendo a formata√ß√£o bonita do original)
(def line1 "* hard    core            0")
(def line2 "root            hard    core            0")
(def marker "# Added by krnl_5820 hardening script")

(defn krnl-5820-check [_opts]
  (println "[KRNL-5820] Verificando configura√ß√£o de core dumps...")

  (if-not (fs/exists? limits-conf)
    (do
      (println (str "‚ö†Ô∏è  Arquivo " limits-conf " n√£o encontrado."))
      false)

    (let [content (slurp limits-conf)]
      ;; Usamos Regex para ser flex√≠vel com espa√ßos em branco (\s+)
      ;; O Perl usava string exata, o que falha se algu√©m editou manualmente com menos espa√ßos.
      (let [has-wildcard (re-find #"^\s*\*\s+hard\s+core\s+0" content)
            has-root     (re-find #"^root\s+hard\s+core\s+0" content)]

        (if (and has-wildcard has-root)
          (do
            (println "‚úîÔ∏è  Core dumps j√° desabilitados.")
            true)
          (do
            (println "‚ùå Core dumps habilitados ou configura√ß√£o incompleta.")
            false))))))

(defn krnl-5820 [opts]
  ;; S√≥ executamos a corre√ß√£o se o check falhar
  (when-not (krnl-5820-check opts)
    (println (str "üîí Desativando core dumps em " limits-conf "..."))

    (if (:dry-run opts)
      (println "‚ÑπÔ∏è  [DRY-RUN] Adicionaria as linhas de restri√ß√£o ao" limits-conf)

      (try
        ;; spit com :append true adiciona ao final do arquivo
        (spit limits-conf (str "\n" marker "\n" line1 "\n" line2 "\n") :append true)
        (println "‚úÖ Core dumps desativados com sucesso.")

        (catch Exception e
          (println (str "üî¥ Erro ao escrever no arquivo: " (.getMessage e)))
          (System/exit 1))))))

; AUTH-9262: Install a PAM module for password strength testing
(def auth-pkg "pam") ;; Nota: No Arch moderno, este m√≥dulo geralmente vem no pacote 'passwdqc'
(def pam-file "/etc/pam.d/passwd")
(def pam-marker "# Added by auth_9262 hardening script")
(def pam-line "password    requisite      pam_passwdqc.so")

(defn package-installed?
  "Verifica se um pacote est√° instalado usando pacman -Q"
  [pkg]
  (let [res (shell {:out :null :err :null :continue true} "pacman -Q" pkg)]
    (= 0 (:exit res))))

(defn auth-9262-check [_opts]
  (println "[AUTH-9262] Verificando m√≥dulo PAM de for√ßa de senha...")

  (let [pkg-ok (package-installed? auth-pkg)]
    (if-not pkg-ok
      (do
        (println (str "? Pacote " auth-pkg " n√£o est√° instalado."))
        false)

      ;; Se o pacote existe, checamos o arquivo
      (if-not (fs/exists? pam-file)
        (do
          (println (str "??  Arquivo " pam-file " n√£o encontrado."))
          false)

        (let [content (slurp pam-file)]
          (if (str/includes? content "pam_passwdqc.so")
            (do
              (println (str "??  pam_passwdqc j√° configurado em " pam-file))
              true)
            (do
              (println (str "? pam_passwdqc ausente em " pam-file))
              false)))))))

(defn auth-9262 [opts]
  ;; O check falhou, ent√£o vamos corrigir
  (when-not (auth-9262-check opts)

    ;; 1. Instala√ß√£o do Pacote
    (when-not (package-installed? auth-pkg)
      (if (:dry-run opts)
        (println (str "?? [DRY-RUN] Instalaria o pacote: " auth-pkg))
        (do
          (println (str "?? Instalando " auth-pkg "..."))
          (let [res (shell {:continue true} "sudo pacman -Sy --noconfirm" auth-pkg)]
            (if (not= 0 (:exit res))
              (throw (ex-info "Falha ao instalar pacote" {:pkg auth-pkg}))
              (println "? Pacote instalado."))))))

    ;; 2. Configura√ß√£o do Arquivo
    ;; Lemos o conte√∫do novamente para garantir (caso o arquivo tenha sido criado na instala√ß√£o do pacote)
    (let [content (if (fs/exists? pam-file) (slurp pam-file) "")]
      (when-not (str/includes? content "pam_passwdqc.so")
        (if (:dry-run opts)
          (println (str "?? [DRY-RUN] Adicionaria configura√ß√£o ao " pam-file))
          (try
            (println (str "?? Escrevendo configura√ß√£o em " pam-file "..."))
            (spit pam-file (str "\n" pam-marker "\n" pam-line "\n") :append true)
            (println "? pam_passwdqc ativado com sucesso.")
            (catch Exception e
              (println (str "?? Erro ao escrever no arquivo: " (.getMessage e)))
              (System/exit 1))))))))

; AUTH-9282: Set password expiration dates for accounts
(defn get-users-without-expiry
  "L√™ o shadow e retorna uma lista de maps {:user ...} que precisam de corre√ß√£o."
  []
  ;; 'sudo getent shadow' √© necess√°rio pois usu√°rios normais n√£o leem os hashes/expira√ß√£o
  (let [res (shell {:out :string :continue true} "sudo getent shadow")]

    (if (not= 0 (:exit res))
      (do
        (println "??  Erro ao ler banco de dados shadow (permiss√£o negada?).")
        []) ;; Retorna lista vazia em caso de erro para n√£o quebrar o fluxo

      (->> (str/split-lines (:out res))
           ;; Parseia a linha do shadow (user:pass:last:min:max:warn:inact:expire:flag)
           (keep (fn [line]
                   (let [parts (str/split line #":")
                         user  (nth parts 0 nil)
                         pass  (nth parts 1 nil)
                         max   (nth parts 4 nil)] ;; Campo 5 √© o MAX days
                     (when (and user pass)
                       {:user user :pass pass :max max}))))

           ;; 1. Filtro de Seguran√ßa (l√≥gica do Perl: next if $pass =~ /^[*!]/)
           ;; Remove contas travadas (!) ou sem login (*)
           (remove (fn [{:keys [pass]}]
                     (re-find #"^[\*\!]" pass)))

           ;; 2. Filtro de Auditoria (l√≥gica do Perl: expire undef, '' ou 99999)
           (filter (fn [{:keys [max]}]
                     (or (str/blank? max)
                         (= "99999" max))))))))

(defn auth-9282-check [_opts]
  (println "[AUTH-9282] Verificando expira√ß√£o de senhas de usu√°rios...")

  (let [vulnerable-users (get-users-without-expiry)]
    (if (seq vulnerable-users)
      (do
        (println (str "? Encontrados " (count vulnerable-users) " usu√°rios com senha sem expira√ß√£o:"))
        (doseq [u vulnerable-users]
          (println (str "   - " (:user u))))
        false) ;; Falha o check
      (do
        (println "??  Todas as contas ativas possuem expira√ß√£o definida.")
        true))))

(defn auth-9282 [opts]
  ;; S√≥ executa se o check falhar
  (when-not (auth-9282-check opts)
    (let [targets (get-users-without-expiry)]

      (doseq [{:keys [user]} targets]
        (if (:dry-run opts)
          (println (str "?? [DRY-RUN] Executaria: sudo chage -M 90 " user))

          (do
            (println (str "??  Aplicando expira√ß√£o (90 dias) para: " user))
            (let [res (shell {:continue true} "sudo chage -M 90" user)]
              (if (= 0 (:exit res))
                (println "   ? Sucesso.")
                (println (str "   ?? Erro ao alterar usu√°rio " user))))))))

    (println "? Processo de expira√ß√£o de senhas conclu√≠do.")))

; AUTH-9286: Configure min/max password age in /etc/login.defs
(def login-defs "/etc/login.defs")
(def min-conf "PASS_MIN_DAYS\t1")  ; Usando \t para manter padr√£o comum do Linux
(def max-conf "PASS_MAX_DAYS\t90")

(defn get-login-defs-value
  "Busca o valor atual de uma chave no arquivo (ex: PASS_MAX_DAYS -> 99999)"
  [content key-name]
  (let [pattern (re-pattern (str "^\\s*" key-name "\\s+(\\d+)"))]
    (some->> (str/split-lines content)
             (keep #(second (re-find pattern %)))
             (first))))

(defn auth-9286-check [_opts]
  (println "[AUTH-9286] Verificando pol√≠tica de idade de senha em /etc/login.defs...")

  (if-not (fs/exists? login-defs)
    (do (println "??  Arquivo n√£o encontrado.") false)

    (let [content (slurp login-defs)
          cur-min (get-login-defs-value content "PASS_MIN_DAYS")
          cur-max (get-login-defs-value content "PASS_MAX_DAYS")]

      (cond
        (and (= cur-min "1") (= cur-max "90"))
        (do (println "??  Pol√≠tica correta (Min: 1, Max: 90).") true)

        :else
        (do
          (println (str "? Configura√ß√£o incorreta ou ausente. (Atual -> Min: " (or cur-min "N/A") ", Max: " (or cur-max "N/A") ")"))
          false)))))

(defn process-login-defs
  "Recebe linhas originais, retorna [linhas-modificadas, flags-encontradas]"
  [lines]
  (let [result (reduce (fn [acc line]
                         (cond
                           (re-find #"^\s*PASS_MIN_DAYS\s+" line)
                           (-> acc
                               (update :lines conj min-conf)
                               (update :found-min (constantly true)))

                           (re-find #"^\s*PASS_MAX_DAYS\s+" line)
                           (-> acc
                               (update :lines conj max-conf)
                               (update :found-max (constantly true)))

                           :else
                           (update acc :lines conj line)))
                       {:lines [] :found-min false :found-max false}
                       lines)]

    ;; Se n√£o encontrou as chaves durante o loop, adiciona no final
    (cond-> result
      (not (:found-min result)) (update :lines conj min-conf)
      (not (:found-max result)) (update :lines conj max-conf))))

(defn auth-9286 [opts]
  (when-not (auth-9286-check opts)
    (println (str "?? Aplicando corre√ß√µes em " login-defs "..."))

    (try
      (let [content (slurp login-defs)
            lines   (str/split-lines content)
            processed (process-login-defs lines)
            new-content (str/join "\n" (:lines processed))]

        (if (:dry-run opts)
          (do
            (println "??  [DRY-RUN] O arquivo seria alterado para:")
            (println "--- INICIO ---")
            (println new-content)
            (println "--- FIM ---"))

          (do
            ;; Escreve o novo conte√∫do (com uma quebra de linha final para ser educado)
            (spit login-defs (str new-content "\n"))
            (println "? Pol√≠tica de idade de senha aplicada com sucesso."))))

      (catch Exception e
        (println (str "?? Erro ao processar arquivo: " (.getMessage e)))
        (System/exit 1)))))


























;; Entrypoint
(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))
