#!/usr/bin/env bb

(require '[babashka.process :refer [shell]]
         '[babashka.fs :as fs]
         '[clojure.string :as str]
         '[clojure.java.io]
         '[clojure.set])
(import '[java.time ZonedDateTime]
        '[java.time.format DateTimeFormatter]
        '[java.util Locale]
        '[java.nio.file Files LinkOption]
        '[java.time LocalDateTime]
        '[java.nio.file Files LinkOption])
;;
;; Reference: https://cisofy.com/lynis/controls/<CODE-NNNN>/

;; --- Configura√ß√£o do Registro ---
;; Aqui unificamos a descri√ß√£o e o mapeamento.
;; As fun√ß√µes (:fix e :check) ser√£o resolvidas dinamicamente baseadas na chave.
(def registry
  {"boot-5264"           {:desc "An√°lise de seguran√ßa dos servi√ßos systemd"}
   "krnl-5820"           {:desc "Desativa core dumps via limits.conf"}
   "auth-9230"           {:desc "Configura hashing rounds para senhas"}
   "auth-9262"           {:desc "Instala m√≥dulo PAM de for√ßa de senha"}
   "auth-9282"           {:desc "Define data de expira√ß√£o para contas"}
   "auth-9286"           {:desc "Configura idade m√≠nima/m√°xima de senha"}
   "auth-9328"           {:desc "Define umask padr√£o mais restrito (027)"}
   "file-6354"           {:desc "Verifica arquivos antigos em /tmp"}
   "usb-1000"            {:desc "Desativa armazenamento USB"}
   "usb-1000_restore"    {:desc "Reativa armazenamento USB"}
   "strg-1846"           {:desc "Desativa suporte a FireWire"}
   "name-4028"           {:desc "Verifica e ajusta dom√≠nio DNS do sistema"}
   "pkgs-7312"           {:desc "Atualiza pacotes (rolling updates)"}
   "pkgs-7320"           {:desc "Instala `arch-audit` para vulnerabilidades"}
   "netw-3200"           {:desc "Desativa protocolos desnecess√°rios (dccp, etc)"}
   "unblock-net_protocols" {:desc "Reativa protocolos desativados"}
   "ssh-7408"            {:desc "Aplica hardening na configura√ß√£o do SSH"}
   "php-2372"            {:desc "Desativa expose_php no php.ini"}
   "php-2376"            {:desc "Desativa allow_url_fopen no php.ini"}
   "logg-2146"           {:desc "Configura rota√ß√£o de logs em /var/log"}
   "bann-7126"           {:desc "Adiciona banner legal ao /etc/issue e issue.net"}
   "acct-9622"           {:desc "Ativa process accounting (accton)"}
   "acct-9626"           {:desc "Ativa coleta com sysstat (sar, iostat)"}
   "acct-9628"           {:desc "Ativa auditd e regras b√°sicas"}
   "acct-report"         {:desc "Relat√≥rio de contabilidade de processos"}
   "audit-report"        {:desc "Relat√≥rio dos eventos de auditd"}
   "time-3104"           {:desc "Ativa sincroniza√ß√£o com systemd-timesyncd"}
   "cryp-7902"           {:desc "Verifica expira√ß√£o de certificados SSL"}
   "fint-4350"           {:desc "Instala AIDE e inicializa integridade de arquivos"}
   "fint-schedule"       {:desc "Agendamento de verifica√ß√£o do AIDE"}
   "tool-5002"           {:desc "Verifica presen√ßa de ferramentas de automa√ß√£o"}
   "file-7524"           {:desc "Corrige permiss√µes inseguras de arquivos"}
   "krnl-6000"           {:desc "Aplica sysctl seguros e gera backup"}
   "krnl-6000_restore"   {:desc "Restaura sysctl a partir de backup salvo"}
   "hrdn-7222"           {:desc "Restringe uso de compiladores por usu√°rios"}
   "hrdn-7222_prune"     {:desc "Remove compiladores n√£o autorizados"}
   "hrdn-7230"           {:desc "Instala e agenda scanner com rkhunter"}})

;; --- Helpers de Resolu√ß√£o ---

(defn to-symbol
  "Converte 'boot_5264' em symbol 'boot-5264' (ou 'boot-5264-check')."
  [action-name suffix]
  (let [kebab-name (str/replace action-name "_" "-")
        full-name (if suffix (str kebab-name "-" suffix) kebab-name)]
    (symbol full-name)))

(defn resolve-fn
  "Tenta encontrar a fun√ß√£o no namespace atual."
  [action-name type]
  (let [func-sym (to-symbol action-name (when (= type :check) "check"))
        f (resolve func-sym)]
    (if f
      f
      (throw (ex-info (str "Fun√ß√£o n√£o implementada: " func-sym) {:fn func-sym})))))

(defn print-help []
  (println "\nüîê Arch Linux Hardening Script (Babashka Port)")
  (println "Uso: hardening <a√ß√£o> [--dry-run] [--auto] [--check-only]\n")
  (println "A√ß√µes dispon√≠veis:")
  (doseq [k (sort (keys registry))]
    (println (format "  %-25s %s" k (get-in registry [k :desc]))))
  (println "\nUse --dry-run para simular e --auto para execu√ß√£o sem perguntas.")
  (System/exit 0))

;; --- Fun√ß√£o Main ---

(defn -main [& args]
  (let [args-set (set args)
        ;; Identifica a a√ß√£o (o primeiro argumento que n√£o come√ßa com --)
        action (first (remove #(str/starts-with? % "--") args))

        options {:dry-run    (contains? args-set "--dry-run")
                 :auto       (contains? args-set "--auto")
                 :check-only (contains? args-set "--check-only")}]

    (cond
      (or (nil? action)
          (contains? args-set "--help")
          (contains? args-set "-h"))
      (print-help)

      (not (contains? registry action))
      (do
        (println (str "‚ùå A√ß√£o desconhecida: " action))
        (println "Use --help para listar as a√ß√µes dispon√≠veis.")
        (System/exit 1))

      :else
      (try
        (println (str "üöÄ Iniciando m√≥dulo: " action))

        ;; L√≥gica da nova arquitetura:
        ;; 1. Resolvemos as fun√ß√µes baseadas no nome da string (snake -> kebab)
        (let [fn-fix   (resolve-fn action :fix)
              fn-check (resolve-fn action :check)]

          ;; Se o usu√°rio pediu apenas check, ou se estamos rodando o fix normal
          ;; Aqui voc√™ pode decidir a l√≥gica. Por exemplo:
          ;; O padr√£o do script Perl era rodar a corre√ß√£o.

          (if (:check-only options)
            (if (fn-check options)
              (println "‚úÖ Verifica√ß√£o OK")
              (println "‚ö†Ô∏è  Verifica√ß√£o FALHOU (A√ß√£o necess√°ria)"))

            ;; Fluxo padr√£o: Executar a corre√ß√£o
            (fn-fix options)))

       (catch Exception e
         (println (str "\nüî¥ Erro cr√≠tico: " (.getMessage e)))
         ;; (println (ex-data e)) ;; Descomente para debug
         (System/exit 1))))))


; BOOT-5264: Consider hardening system services
; Run '/usr/bin/systemd-analyze security SERVICE' for each service

(defn get-running-services
  "Retorna uma lista de nomes de servi√ßos ativos (ex: sshd.service)."
  []
  (let [res (shell {:out :string} "systemctl list-units --type=service --state=running --no-legend --plain")
        lines (str/split-lines (:out res))]
    (->> lines
         (map #(first (str/split % #"\s+")))        ;; Pega a primeira coluna
         (filter #(str/ends-with? % ".service"))))) ;; Garante que √© .service

(defn boot-5264-check [_opts]
  (println "üîç [BOOT-5264] Verificando pontua√ß√£o de seguran√ßa global...")

  ;; systemd-analyze security sem argumentos lista todos os servi√ßos com score
  ;; Formato: UNIT EXPOSURE PREDICATE HAPPY
  (let [res (shell {:out :string :continue true} "systemd-analyze security --no-pager")
        lines (drop 1 (str/split-lines (:out res))) ;; Remove cabe√ßalho
        threshold 5.0] ;; Defina seu limiar de toler√¢ncia aqui

    (if (not= 0 (:exit res))
      (do
        (println "‚ö†Ô∏è  systemd-analyze n√£o encontrado ou falhou.")
        false) ;; Falha se n√£o conseguir rodar

      (let [risky-services (->> lines
                                (map (fn [line]
                                       (let [parts (str/split (str/trim line) #"\s+")
                                             unit  (first parts)
                                             score (try (Double/parseDouble (nth parts 1))
                                                        (catch Exception _ 0.0))]
                                         {:unit unit :score score})))
                                (filter #(> (:score %) threshold)))]

        (if (seq risky-services)
          (do
            (println (str "‚ùå Encontrados " (count risky-services) " servi√ßos com exposi√ß√£o > " threshold))
            ;; Retorna false para indicar que a verifica√ß√£o falhou e o 'fix' deve rodar
            false)
          (do
            (println "‚úÖ Todos os servi√ßos est√£o dentro dos limites de seguran√ßa.")
            true))))))

(defn boot-5264 []
  (println "\n[BOOT-5264] Iniciando an√°lise detalhada (Hardening System Services)...")

  (let [services (get-running-services)]
    (println (str "‚ÑπÔ∏è  Servi√ßos identificados: " (count services)))

    (doseq [service services]
      (println (str "\nüîç Analisando seguran√ßa detalhada de: " service))
      ;; Aqui replicamos o comportamento do Perl: rodar a an√°lise detalhada por servi√ßo
      ;; Usamos :continue true pois alguns servi√ßos podem dar erro de permiss√£o ou n√£o suportar an√°lise
      (let [res (shell {:out :string :continue true} "systemd-analyze" "security" service)]
        (println (:out res)))))

  (println "\n[BOOT-5264] An√°lise conclu√≠da.")
  (println "üëâ A√ß√£o recomendada: Revise os servi√ßos acima com pontua√ß√£o 'UNSAFE' e adicione diretivas de sandboxing (ex: ProtectSystem, PrivateTmp) nos unit files."))


; KRNL-5820: Disable core dumps via limits.conf
; https://linux-audit.com/software/understand-and-configure-core-dumps-work-on-linux/
(def limits-conf "/etc/security/limits.conf")

;; Strings exatas para escrita (mantendo a formata√ß√£o bonita do original)
(def line1 "* hard    core            0")
(def line2 "root            hard    core            0")
(def marker "# Added by krnl_5820 hardening script")

(defn krnl-5820-check [_opts]
  (println "[KRNL-5820] Verificando configura√ß√£o de core dumps...")

  (if-not (fs/exists? limits-conf)
    (do
      (println (str "‚ö†Ô∏è  Arquivo " limits-conf " n√£o encontrado."))
      false)

    (let [content (slurp limits-conf)]
      ;; Usamos Regex para ser flex√≠vel com espa√ßos em branco (\s+)
      ;; O Perl usava string exata, o que falha se algu√©m editou manualmente com menos espa√ßos.
      (let [has-wildcard (re-find #"^\s*\*\s+hard\s+core\s+0" content)
            has-root     (re-find #"^root\s+hard\s+core\s+0" content)]

        (if (and has-wildcard has-root)
          (do
            (println "‚úîÔ∏è  Core dumps j√° desabilitados.")
            true)
          (do
            (println "‚ùå Core dumps habilitados ou configura√ß√£o incompleta.")
            false))))))

(defn krnl-5820 [opts]
  ;; S√≥ executamos a corre√ß√£o se o check falhar
  (when-not (krnl-5820-check opts)
    (println (str "üîí Desativando core dumps em " limits-conf "..."))

    (if (:dry-run opts)
      (println "‚ÑπÔ∏è  [DRY-RUN] Adicionaria as linhas de restri√ß√£o ao" limits-conf)

      (try
        ;; spit com :append true adiciona ao final do arquivo
        (spit limits-conf (str "\n" marker "\n" line1 "\n" line2 "\n") :append true)
        (println "‚úÖ Core dumps desativados com sucesso.")

        (catch Exception e
          (println (str "üî¥ Erro ao escrever no arquivo: " (.getMessage e)))
          (System/exit 1))))))

; AUTH-9262: Install a PAM module for password strength testing
(def auth-pkg "pam") ;; Nota: No Arch moderno, este m√≥dulo geralmente vem no pacote 'passwdqc'
(def pam-file "/etc/pam.d/passwd")
(def pam-marker "# Added by auth_9262 hardening script")
(def pam-line "password    requisite      pam_passwdqc.so")

(defn package-installed?
  "Verifica se um pacote est√° instalado usando pacman -Q"
  [pkg]
  (let [res (shell {:out :null :err :null :continue true} "pacman -Q" pkg)]
    (= 0 (:exit res))))

(defn auth-9262-check [_opts]
  (println "[AUTH-9262] Verificando m√≥dulo PAM de for√ßa de senha...")

  (let [pkg-ok (package-installed? auth-pkg)]
    (if-not pkg-ok
      (do
        (println (str "? Pacote " auth-pkg " n√£o est√° instalado."))
        false)

      ;; Se o pacote existe, checamos o arquivo
      (if-not (fs/exists? pam-file)
        (do
          (println (str "??  Arquivo " pam-file " n√£o encontrado."))
          false)

        (let [content (slurp pam-file)]
          (if (str/includes? content "pam_passwdqc.so")
            (do
              (println (str "??  pam_passwdqc j√° configurado em " pam-file))
              true)
            (do
              (println (str "? pam_passwdqc ausente em " pam-file))
              false)))))))

(defn auth-9262 [opts]
  ;; O check falhou, ent√£o vamos corrigir
  (when-not (auth-9262-check opts)

    ;; 1. Instala√ß√£o do Pacote
    (when-not (package-installed? auth-pkg)
      (if (:dry-run opts)
        (println (str "?? [DRY-RUN] Instalaria o pacote: " auth-pkg))
        (do
          (println (str "?? Instalando " auth-pkg "..."))
          (let [res (shell {:continue true} "sudo pacman -Sy --noconfirm" auth-pkg)]
            (if (not= 0 (:exit res))
              (throw (ex-info "Falha ao instalar pacote" {:pkg auth-pkg}))
              (println "? Pacote instalado."))))))

    ;; 2. Configura√ß√£o do Arquivo
    ;; Lemos o conte√∫do novamente para garantir (caso o arquivo tenha sido criado na instala√ß√£o do pacote)
    (let [content (if (fs/exists? pam-file) (slurp pam-file) "")]
      (when-not (str/includes? content "pam_passwdqc.so")
        (if (:dry-run opts)
          (println (str "?? [DRY-RUN] Adicionaria configura√ß√£o ao " pam-file))
          (try
            (println (str "?? Escrevendo configura√ß√£o em " pam-file "..."))
            (spit pam-file (str "\n" pam-marker "\n" pam-line "\n") :append true)
            (println "? pam_passwdqc ativado com sucesso.")
            (catch Exception e
              (println (str "?? Erro ao escrever no arquivo: " (.getMessage e)))
              (System/exit 1))))))))

; AUTH-9282: Set password expiration dates for accounts
(defn get-users-without-expiry
  "L√™ o shadow e retorna uma lista de maps {:user ...} que precisam de corre√ß√£o."
  []
  ;; 'sudo getent shadow' √© necess√°rio pois usu√°rios normais n√£o leem os hashes/expira√ß√£o
  (let [res (shell {:out :string :continue true} "sudo getent shadow")]

    (if (not= 0 (:exit res))
      (do
        (println "??  Erro ao ler banco de dados shadow (permiss√£o negada?).")
        []) ;; Retorna lista vazia em caso de erro para n√£o quebrar o fluxo

      (->> (str/split-lines (:out res))
           ;; Parseia a linha do shadow (user:pass:last:min:max:warn:inact:expire:flag)
           (keep (fn [line]
                   (let [parts (str/split line #":")
                         user  (nth parts 0 nil)
                         pass  (nth parts 1 nil)
                         max   (nth parts 4 nil)] ;; Campo 5 √© o MAX days
                     (when (and user pass)
                       {:user user :pass pass :max max}))))

           ;; 1. Filtro de Seguran√ßa (l√≥gica do Perl: next if $pass =~ /^[*!]/)
           ;; Remove contas travadas (!) ou sem login (*)
           (remove (fn [{:keys [pass]}]
                     (re-find #"^[\*\!]" pass)))

           ;; 2. Filtro de Auditoria (l√≥gica do Perl: expire undef, '' ou 99999)
           (filter (fn [{:keys [max]}]
                     (or (str/blank? max)
                         (= "99999" max))))))))

(defn auth-9282-check [_opts]
  (println "[AUTH-9282] Verificando expira√ß√£o de senhas de usu√°rios...")

  (let [vulnerable-users (get-users-without-expiry)]
    (if (seq vulnerable-users)
      (do
        (println (str "? Encontrados " (count vulnerable-users) " usu√°rios com senha sem expira√ß√£o:"))
        (doseq [u vulnerable-users]
          (println (str "   - " (:user u))))
        false) ;; Falha o check
      (do
        (println "??  Todas as contas ativas possuem expira√ß√£o definida.")
        true))))

(defn auth-9282 [opts]
  ;; S√≥ executa se o check falhar
  (when-not (auth-9282-check opts)
    (let [targets (get-users-without-expiry)]

      (doseq [{:keys [user]} targets]
        (if (:dry-run opts)
          (println (str "?? [DRY-RUN] Executaria: sudo chage -M 90 " user))

          (do
            (println (str "??  Aplicando expira√ß√£o (90 dias) para: " user))
            (let [res (shell {:continue true} "sudo chage -M 90" user)]
              (if (= 0 (:exit res))
                (println "   ? Sucesso.")
                (println (str "   ?? Erro ao alterar usu√°rio " user))))))))

    (println "? Processo de expira√ß√£o de senhas conclu√≠do.")))

; AUTH-9286: Configure min/max password age in /etc/login.defs
(def login-defs "/etc/login.defs")
(def min-conf "PASS_MIN_DAYS\t1")  ; Usando \t para manter padr√£o comum do Linux
(def max-conf "PASS_MAX_DAYS\t90")

(defn get-login-defs-value
  "Busca o valor atual de uma chave no arquivo (ex: PASS_MAX_DAYS -> 99999)"
  [content key-name]
  (let [pattern (re-pattern (str "^\\s*" key-name "\\s+(\\d+)"))]
    (some->> (str/split-lines content)
             (keep #(second (re-find pattern %)))
             (first))))

(defn auth-9286-check [_opts]
  (println "[AUTH-9286] Verificando pol√≠tica de idade de senha em /etc/login.defs...")

  (if-not (fs/exists? login-defs)
    (do (println "??  Arquivo n√£o encontrado.") false)

    (let [content (slurp login-defs)
          cur-min (get-login-defs-value content "PASS_MIN_DAYS")
          cur-max (get-login-defs-value content "PASS_MAX_DAYS")]

      (cond
        (and (= cur-min "1") (= cur-max "90"))
        (do (println "??  Pol√≠tica correta (Min: 1, Max: 90).") true)

        :else
        (do
          (println (str "? Configura√ß√£o incorreta ou ausente. (Atual -> Min: " (or cur-min "N/A") ", Max: " (or cur-max "N/A") ")"))
          false)))))

(defn process-login-defs
  "Recebe linhas originais, retorna [linhas-modificadas, flags-encontradas]"
  [lines]
  (let [result (reduce (fn [acc line]
                         (cond
                           (re-find #"^\s*PASS_MIN_DAYS\s+" line)
                           (-> acc
                               (update :lines conj min-conf)
                               (update :found-min (constantly true)))

                           (re-find #"^\s*PASS_MAX_DAYS\s+" line)
                           (-> acc
                               (update :lines conj max-conf)
                               (update :found-max (constantly true)))

                           :else
                           (update acc :lines conj line)))
                       {:lines [] :found-min false :found-max false}
                       lines)]

    ;; Se n√£o encontrou as chaves durante o loop, adiciona no final
    (cond-> result
      (not (:found-min result)) (update :lines conj min-conf)
      (not (:found-max result)) (update :lines conj max-conf))))

(defn auth-9286 [opts]
  (when-not (auth-9286-check opts)
    (println (str "?? Aplicando corre√ß√µes em " login-defs "..."))

    (try
      (let [content (slurp login-defs)
            lines   (str/split-lines content)
            processed (process-login-defs lines)
            new-content (str/join "\n" (:lines processed))]

        (if (:dry-run opts)
          (do
            (println "??  [DRY-RUN] O arquivo seria alterado para:")
            (println "--- INICIO ---")
            (println new-content)
            (println "--- FIM ---"))

          (do
            ;; Escreve o novo conte√∫do (com uma quebra de linha final para ser educado)
            (spit login-defs (str new-content "\n"))
            (println "? Pol√≠tica de idade de senha aplicada com sucesso."))))

      (catch Exception e
        (println (str "?? Erro ao processar arquivo: " (.getMessage e)))
        (System/exit 1)))))


; AUTH-9230: Configure password hashing rounds in /etc/login.defs
; https://linux-audit.com/authentication/configure-the-minimum-password-length-on-linux-systems/
(def rounds-target "65536")
(def rounds-line (str "SHA_CRYPT_ROUNDS " rounds-target))
(def rounds-marker "# Added by auth_9230 hardening script")

(defn get-current-rounds
  "Extrai o valor atual de SHA_CRYPT_ROUNDS do conte√∫do do arquivo."
  [content]
  (let [pattern #"^\s*SHA_CRYPT_ROUNDS\s+(\d+)"]
    (some->> (str/split-lines content)
             (keep #(second (re-find pattern %))) ;; Extrai o grupo de captura (\d+)
             (first))))

(defn auth-9230-check [_opts]
  (println "[AUTH-9230] Verificando rounds de hash de senha...")

  (if-not (fs/exists? login-defs)
    (do (println "??  Arquivo n√£o encontrado.") false)

    (let [content (slurp login-defs)
          current (get-current-rounds content)]

      (if (= current rounds-target)
        (do
          (println (str "??  SHA_CRYPT_ROUNDS j√° est√° configurado corretamente (" rounds-target ")."))
          true)
        (do
          (println (str "? Configura√ß√£o incorreta. Valor atual: " (or current "N√£o definido") " (Esperado: " rounds-target ")"))
          false)))))

(defn process-rounds-config
  "Substitui a linha existente ou indica que precisa adicionar no final."
  [lines]
  (reduce (fn [acc line]
            (if (re-find #"^\s*SHA_CRYPT_ROUNDS\s+" line)
              ;; Se encontrou, substitui pela linha correta e marca flag found
              (-> acc
                  (update :lines conj rounds-line)
                  (assoc :found true))
              ;; Se n√£o, mant√©m a linha original
              ;; CORRE√á√ÉO: Adicionado 'acc' como primeiro argumento
              (update acc :lines conj line)))
          {:lines [] :found false}
          lines))

(defn auth-9230 [opts]
  (when-not (auth-9230-check opts)
    (println (str "?? Ajustando SHA_CRYPT_ROUNDS em " login-defs "..."))

    (try
      (let [content (slurp login-defs)
            lines   (str/split-lines content)
            result  (process-rounds-config lines)

            ;; Se n√£o encontrou a chave no loop, adiciona o marcador e a linha no final
            final-lines (if (:found result)
                          (:lines result)
                          (concat (:lines result) ["" rounds-marker rounds-line]))]

        (if (:dry-run opts)
          (do
            (println "??  [DRY-RUN] O arquivo seria atualizado para conter:")
            (println (str/join "\n" (filter #(str/includes? % "SHA_CRYPT_ROUNDS") final-lines))))

          (do
            (spit login-defs (str (str/join "\n" final-lines) "\n"))
            (println "? SHA_CRYPT_ROUNDS ajustado para 65536 com sucesso."))))

      (catch Exception e
        (println (str "?? Erro ao manipular arquivo: " (.getMessage e)))
        (System/exit 1)))))

; AUTH-9328: Enforce umask 027 in /etc/login.defs
(def target-umask "027")
(def umask-line (str "UMASK " target-umask))

(defn get-current-umask
  "Extrai o valor atual do UMASK do conte√∫do do arquivo."
  [content]
  (let [pattern #"^\s*UMASK\s+(\d+)"]
    (some->> (str/split-lines content)
             (keep #(second (re-find pattern %))) ;; Pega o valor capturado
             (first))))

(defn auth-9328-check [_opts]
  (println "[AUTH-9328] Verificando configura√ß√£o de umask padr√£o...")

  (if-not (fs/exists? login-defs)
    (do (println "??  Arquivo /etc/login.defs n√£o encontrado.") false)

    (let [content (slurp login-defs)
          current (get-current-umask content)]

      (if (= current target-umask)
        (do
          (println (str "??  UMASK j√° configurado como " target-umask "."))
          true)
        (do
          (println (str "? Configura√ß√£o incorreta. Valor atual: " (or current "N√£o definido") " (Esperado: " target-umask ")"))
          false)))))

(defn process-umask-config
  "Processa as linhas substituindo UMASK se existir."
  [lines]
  (reduce (fn [acc line]
            (if (re-find #"^\s*UMASK\s+" line)
              ;; Se encontrar, substitui e marca flag
              (-> acc
                  (update :lines conj umask-line)
                  (assoc :found true))
              ;; Se n√£o, mant√©m a linha
              (update acc :lines conj line)))
          {:lines [] :found false}
          lines))

(defn auth-9328 [opts]
  (when-not (auth-9328-check opts)
    (println (str "?? Ajustando UMASK em " login-defs "..."))

    (try
      (let [content (slurp login-defs)
            lines   (str/split-lines content)
            result  (process-umask-config lines)

            ;; Se n√£o encontrou no loop, adiciona ao final
            final-lines (if (:found result)
                          (:lines result)
                          (conj (:lines result) umask-line))]

        (if (:dry-run opts)
          (do
            (println "??  [DRY-RUN] O arquivo seria atualizado para conter:")
            (println (str/join "\n" (filter #(str/includes? % "UMASK") final-lines))))

          (do
            (spit login-defs (str (str/join "\n" final-lines) "\n"))
            (println "? umask padr√£o ajustado para 027 com sucesso."))))

      (catch Exception e
        (println (str "?? Erro ao manipular arquivo: " (.getMessage e)))
        (System/exit 1)))))

; FILE-6354: Check and optionally delete files in /tmp older than 90 days
(defn get-old-tmp-files
  "Executa o find para localizar arquivos com mtime +90 em /tmp."
  []
  ;; Equivalente ao `find /tmp ... 2>/dev/null` do Perl
  (let [res (shell {:out :string :err :null :continue true}
                   "find /tmp -type f -mtime +90")]
    (if (not= 0 (:exit res))
      []
      (->> (str/split-lines (:out res))
           (remove str/blank?)))))

(defn file-6354-check [_opts]
  (println "[FILE-6354] Verificando arquivos em /tmp com mais de 90 dias...")

  (let [files (get-old-tmp-files)]
    (if (empty? files)
      (do
        (println "‚úÖ Nenhum arquivo antigo encontrado em /tmp.")
        true)
      (do
        (println (str "‚ö†Ô∏è  Encontrados " (count files) " arquivo(s) com mais de 90 dias:"))
        (doseq [f (take 10 files)] ;; Mostra apenas os 10 primeiros para n√£o poluir
          (println (str "   - " f)))
        (when (> (count files) 10)
          (println (str "   ... e mais " (- (count files) 10) " arquivos.")))
        false))))

(defn confirm-deletion? []
  (print "\nDeseja remover todos os arquivos listados acima? [s/N] ")
  (flush) ;; Garante que o print apare√ßa antes de pedir input
  (let [input (str/trim (or (read-line) ""))]
    (= "s" (str/lower-case input))))

(defn file-6354 [opts]
  ;; Se o check retornar true (sem arquivos), n√£o fazemos nada.
  (when-not (file-6354-check opts)
    (let [files (get-old-tmp-files)]

      ;; L√≥gica de decis√£o: Deletar ou n√£o?
      (cond
        (:dry-run opts)
        (println (str "üßπ [DRY-RUN] " (count files) " arquivos seriam removidos."))

        ;; Se for auto, deleta direto. Se n√£o, pergunta.
        (or (:auto opts) (confirm-deletion?))
        (let [deleted-count (atom 0)]
          (println "\nüóëÔ∏è  Removendo arquivos...")

          (doseq [f files]
            (try
              (fs/delete f)
              (swap! deleted-count inc)
              (catch Exception e
                (println (str "üî¥ Erro ao remover " f ": " (.getMessage e))))))

          (println (str "üßπ " @deleted-count " arquivo(s) removido(s) com sucesso.")))

        :else
        (println "‚ùé Opera√ß√£o cancelada pelo usu√°rio. Nenhum arquivo foi removido.")))))


; USB-1000: Disable USB storage module if not in use

(def usb-conf-file "/etc/modprobe.d/usb-storage.conf")
(def blacklist-line "blacklist usb-storage")

(defn usb-storage-loaded?
  "Verifica se o m√≥dulo est√° carregado na mem√≥ria (lsmod)."
  []
  (let [res (shell {:out :string :continue true} "lsmod")]
    (if (not= 0 (:exit res))
      false ;; Se lsmod falhar, assumimos que n√£o conseguimos verificar
      (re-find #"^usb_storage\b" (:out res)))))

(defn usb-config-ok?
  "Verifica se o arquivo de configura√ß√£o existe e cont√©m o blacklist."
  []
  (if-not (fs/exists? usb-conf-file)
    false
    (let [content (slurp usb-conf-file)]
      (boolean (re-find #"^\s*blacklist\s+usb-storage\b" content)))))

(defn usb-1000-check [_opts]
  (println "[USB-1000] Verificando bloqueio do m√≥dulo usb-storage...")

  (let [conf-ok (usb-config-ok?)
        loaded  (usb-storage-loaded?)]

    (cond
      (and conf-ok (not loaded))
      (do (println "‚úîÔ∏è  M√≥dulo usb-storage bloqueado e descarregado.") true)

      (not conf-ok)
      (do (println (str "‚ùå Configura√ß√£o de blacklist ausente em " usb-conf-file)) false)

      loaded
      (do (println "‚ö†Ô∏è  Configura√ß√£o existe, mas o m√≥dulo usb_storage ainda est√° carregado na mem√≥ria.") false))))

(defn confirm-unload? []
  (print "‚ö†Ô∏è  O m√≥dulo usb_storage est√° carregado. Deseja descarreg√°-lo agora? [s/N] ")
  (flush)
  (let [input (str/trim (or (read-line) ""))]
    (= "s" (str/lower-case input))))

(defn usb-1000 [opts]
  ;; 1. Ajuste da Configura√ß√£o (Persist√™ncia)
  (when-not (usb-config-ok?)
    (if (:dry-run opts)
      (println (str "üîí [DRY-RUN] Criaria " usb-conf-file " com blacklist."))
      (try
        (println (str "üìù Criando regra de blacklist em " usb-conf-file "..."))
        ;; Garante que o diret√≥rio pai existe
        (fs/create-dirs (fs/parent usb-conf-file))
        (spit usb-conf-file (str blacklist-line "\n") :append true)
        (println "‚úÖ Configura√ß√£o aplicada com sucesso.")
        (catch Exception e
          (println (str "üî¥ Erro ao escrever arquivo: " (.getMessage e)))))))

  ;; 2. Ajuste do Runtime (Mem√≥ria)
  (when (usb-storage-loaded?)
    (cond
      (:dry-run opts)
      (println "üßπ [DRY-RUN] Executaria 'modprobe -r usb-storage' agora.")

      ;; Se for auto ou usu√°rio confirmar
      (or (:auto opts) (confirm-unload?))
      (do
        (println "‚öôÔ∏è  Tentando descarregar m√≥dulo...")
        (let [res (shell {:continue true} "sudo modprobe -r usb-storage")]
          (if (= 0 (:exit res))
            (println "‚úÖ M√≥dulo descarregado com sucesso.")
            (println "‚ùå Falha ao descarregar (o m√≥dulo pode estar em uso). Reinicie o sistema para aplicar."))))

      :else
      (println "üîê Aten√ß√£o: O m√≥dulo permanecer√° ativo at√© o pr√≥ximo reboot."))))

; STRG-1846: Disable FireWire storage drivers if not in use
(def fw-conf-file "/etc/modprobe.d/firewire.conf")
(def fw-modules ["firewire-core" "firewire-ohci" "firewire-sbp2"])

(defn firewire-loaded?
  "Verifica se algum m√≥dulo firewire est√° carregado via lsmod."
  []
  ;; grep gen√©rico por 'firewire' pega firewire_core, firewire_ohci, etc.
  (let [res (shell {:out :string :continue true} "lsmod")]
    (if (not= 0 (:exit res))
      false
      (boolean (re-find #"firewire" (:out res))))))

(defn get-missing-blacklists
  "Retorna lista de m√≥dulos que ainda N√ÉO est√£o no arquivo de conf."
  []
  (if-not (fs/exists? fw-conf-file)
    fw-modules ;; Se arquivo n√£o existe, todos faltam
    (let [content (slurp fw-conf-file)]
      (filter (fn [mod-name]
                ;; Verifica: blacklist module-name (com borda de palavra \b)
                (not (re-find (re-pattern (str "^\\s*blacklist\\s+" mod-name "\\b"))
                              content)))
              fw-modules))))

(defn strg-1846-check [_opts]
  (println "[STRG-1846] Verificando bloqueio de m√≥dulos FireWire...")

  (let [missing (get-missing-blacklists)
        loaded  (firewire-loaded?)]

    (cond
      (and (empty? missing) (not loaded))
      (do (println "‚úîÔ∏è  Todos os m√≥dulos FireWire bloqueados e inativos.") true)

      (seq missing)
      (do
        (println (str "‚ùå Configura√ß√£o incompleta. Faltam blacklists para: " (str/join ", " missing)))
        false)

      loaded
      (do (println "‚ö†Ô∏è  Configura√ß√£o existe, mas m√≥dulos FireWire ainda est√£o ativos na mem√≥ria.") false))))

(defn confirm-fw-unload? []
  (print "‚ö†Ô∏è  M√≥dulos FireWire detectados. Deseja descarreg√°-los agora? [s/N] ")
  (flush)
  (let [input (str/trim (or (read-line) ""))]
    (= "s" (str/lower-case input))))

(defn strg-1846 [opts]
  ;; 1. Corre√ß√£o da Configura√ß√£o (Persist√™ncia)
  (let [missing (get-missing-blacklists)]
    (when (seq missing)
      (if (:dry-run opts)
        (println (str "üîí [DRY-RUN] Adicionaria ao " fw-conf-file ": " (str/join ", " missing)))

        (try
          (println (str "üìù Atualizando " fw-conf-file "..."))
          (fs/create-dirs (fs/parent fw-conf-file))

          ;; Gera as linhas novas
          (let [new-lines (map #(str "blacklist " %) missing)]
            (spit fw-conf-file (str (str/join "\n" new-lines) "\n") :append true))

          (println (str "‚úÖ M√≥dulos bloqueados na configura√ß√£o: " (str/join ", " missing)))
          (catch Exception e
            (println (str "üî¥ Erro ao escrever arquivo: " (.getMessage e))))))))

  ;; 2. Corre√ß√£o do Runtime (Mem√≥ria)
  (when (firewire-loaded?)
    (cond
      (:dry-run opts)
      (println "üßπ [DRY-RUN] Executaria 'modprobe -r' nos m√≥dulos FireWire.")

      (or (:auto opts) (confirm-fw-unload?))
      (do
        (println "‚öôÔ∏è  Tentando descarregar m√≥dulos...")
        (doseq [mod fw-modules]
          ;; Tenta descarregar um por um. Ignoramos erros individuais (pois depend√™ncias podem reclamar)
          (shell {:continue true} "sudo modprobe -r" mod))

        ;; Verifica√ß√£o final p√≥s-tentativa
        (if (firewire-loaded?)
          (println "‚ö†Ô∏è  Alguns m√≥dulos ainda est√£o ativos (verifique depend√™ncias).")
          (println "‚úÖ M√≥dulos descarregados com sucesso.")))

      :else
      (println "üîê Os m√≥dulos permanecer√£o carregados at√© o pr√≥ximo reboot."))))

; NAME-4028: Verifica e corrige a configura√ß√£o do nome DNS (FQDN)

(defn get-dns-info
  "Coleta hostname, fqdn e domain name do sistema."
  []
  ;; Usamos :continue true para n√£o estourar erro se o comando falhar (comum se mal configurado)
  (let [sh-val (fn [cmd]
                 (-> (shell {:out :string :err :null :continue true} cmd)
                     :out
                     str/trim))
        hostname (sh-val "hostname")
        fqdn     (sh-val "hostname --fqdn")
        domain   (sh-val "dnsdomainname")]
    {:hostname hostname :fqdn fqdn :domain domain}))

(defn valid-fqdn?
  "Replica a l√≥gica de valida√ß√£o do Perl."
  [{:keys [hostname fqdn domain]}]
  (cond
    (str/blank? fqdn) false
    (= fqdn hostname) false
    (not (str/includes? fqdn ".")) false
    (= domain "(none)") false
    (str/blank? domain) false
    :else true))

(defn name-4028-check [_opts]
  (println "[NAME-4028] Verificando configura√ß√£o de nome DNS (FQDN)...")

  (let [info (get-dns-info)]
    (println (str "üìõ hostname: " (:hostname info)))
    (println (str "üåê FQDN:      " (:fqdn info)))
    (println (str "üåç dom√≠nio:   " (:domain info)))

    (if (valid-fqdn? info)
      (do
        (println "‚úÖ Nome de dom√≠nio DNS configurado corretamente.")
        true)
      (do
        (println "‚ö†Ô∏è  FQDN ou dom√≠nio DNS ausente ou incorreto.")
        false))))

(defn update-hosts-file
  "L√™ /etc/hosts, remove linhas antigas de 127.0.1.1 e adiciona a nova."
  [fqdn hostname]
  (let [hosts-file "/etc/hosts"
        content    (slurp hosts-file)
        lines      (str/split-lines content)

        ;; Filtra removendo qualquer linha que comece com 127.0.1.1
        clean-lines (remove #(re-find #"^127\.0\.1\.1\s+" %) lines)

        ;; Cria a nova linha (Tab separated)
        new-line    (str "127.0.1.1\t" fqdn " " hostname)

        ;; Junta tudo
        final-content (str (str/join "\n" clean-lines) "\n" new-line "\n")]

    (spit hosts-file final-content)))

(defn name-4028 [opts]
  (when-not (name-4028-check opts)
    (println "üîß Voc√™ pode corrigir isso agora.")

    ;; NAME-4028 √© especial: n√£o podemos automatizar (--auto) sem saber o nome.
    ;; Se estiver em modo auto ou dry-run, pulamos a intera√ß√£o.
    (if (:auto opts)
      (println "‚ö†Ô∏è  [AUTO] Pulei a configura√ß√£o pois requer input manual do nome.")

      (if (:dry-run opts)
        (println "‚ÑπÔ∏è  [DRY-RUN] Solicitaria novo FQDN e aplicaria as mudan√ßas.")

        ;; Modo Interativo
        (do
          (print "Deseja configurar um FQDN agora? [s/N] ")
          (flush)
          (let [resp (str/trim (or (read-line) ""))]
            (if-not (= "s" (str/lower-case resp))
              (println "‚ùé Nenhuma altera√ß√£o realizada.")

              (do
                (print "Digite o FQDN desejado (ex: servidor1.exemplo.com): ")
                (flush)
                (let [new-fqdn (str/trim (read-line))]
                  ;; Valida√ß√£o Regex
                  (if-not (re-matches #"^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$" new-fqdn)
                    (println "‚ùå FQDN inv√°lido. Deve conter pelo menos um ponto e caracteres v√°lidos.")

                    (let [[new-host _] (str/split new-fqdn #"\." 2)]
                      (println (str "‚öôÔ∏è  Configurando Host: " new-host " / FQDN: " new-fqdn))

                      (try
                        ;; 1. /etc/hostname
                        (spit "/etc/hostname" (str new-host "\n"))

                        ;; 2. /etc/hosts
                        (update-hosts-file new-fqdn new-host)

                        ;; 3. hostnamectl
                        (let [res (shell {:continue true} "hostnamectl set-hostname" new-fqdn)]
                          (if (= 0 (:exit res))
                            (println (str "‚úÖ FQDN configurado com sucesso: " new-fqdn))
                            (println "‚ùå Erro ao aplicar hostname com hostnamectl.")))

                        (catch Exception e
                          (println (str "üî¥ Erro cr√≠tico ao aplicar configura√ß√µes: " (.getMessage e))))))))))))))))

; PKGS-7312: Atualizar sistema rolling release (ex: Arch Linux)

(defn get-pending-updates
  "Retorna lista de atualiza√ß√µes. Retorna nil se checkupdates falhar/n√£o existir."
  []
  (if-not (fs/which "checkupdates")
    (do (println "‚ö†Ô∏è  'checkupdates' n√£o encontrado (instale pacman-contrib).") nil)

    ;; checkupdates retorna exit 2 se n√£o houver nada. Ignoramos o erro.
    (let [res (shell {:out :string :err :null :continue true} "checkupdates")]
      (cond
        (= 0 (:exit res)) (str/split-lines (:out res))
        (= 2 (:exit res)) [] ;; Exit 2 = Tudo atualizado
        :else nil))))        ;; Outro erro

(defn pkgs-7312-check [_opts]
  (println "[PKGS-7312] Verificando atualiza√ß√µes do sistema...")

  (let [updates (get-pending-updates)]
    (cond
      (nil? updates) false ;; Falha t√©cnica
      (empty? updates) (do (println "‚úÖ Sistema j√° est√° atualizado.") true)
      :else
      (do
        (println (str "üì¶ H√° " (count updates) " atualiza√ß√£o(√µes) pendente(s)."))
        false))))

(defn pkgs-7312 [opts]
  ;; Se o check falhar (tem updates ou erro), entramos aqui
  (when-not (pkgs-7312-check opts)
    (let [updates (get-pending-updates)]

      (when (seq updates)
        (println "üì¶ Lista de pacotes:")
        (doseq [pkg updates]
          (println (str "   - " pkg)))

        (cond
          (:dry-run opts)
          (println "üîç Modo simula√ß√£o: atualiza√ß√µes n√£o ser√£o aplicadas.")

          ;; Se Auto ou Confirma√ß√£o do usu√°rio
          (or (:auto opts)
              (do
                (print "\nDeseja aplicar as atualiza√ß√µes agora com 'sudo pacman -Syu'? [s/N] ")
                (flush)
                (= "s" (str/lower-case (str/trim (or (read-line) ""))))))
          (do
            (println "‚è≥ Atualizando sistema...")
            (let [res (shell {:continue true} "sudo pacman -Syu")]
              (if (= 0 (:exit res))
                (println "‚úÖ Sistema atualizado com sucesso.")
                (println "‚ùå Erro na atualiza√ß√£o."))))

          :else
          (println "üîï Atualiza√ß√µes n√£o aplicadas."))))))

; PKGS-7320: Instalar e rodar arch-audit para encontrar pacotes vulner√°veis

(defn pkgs-7320-check [_opts]
  (println "[PKGS-7320] Verificando vulnerabilidades (arch-audit)...")

  (if-not (fs/which "arch-audit")
    (do
      (println "‚ö†Ô∏è  Utilit√°rio 'arch-audit' n√£o est√° instalado.")
      false)

    ;; Se instalado, rodamos para ver se detecta algo
    ;; arch-audit retorna 0 se seguro, >0 se vulner√°vel (depende da vers√£o, mas checamos output)
    (let [res (shell {:out :string :continue true} "arch-audit")]
      (if (and (= 0 (:exit res)) (str/blank? (:out res)))
        (do (println "‚úÖ Nenhuma vulnerabilidade conhecida encontrada.") true)
        (do (println "‚ö†Ô∏è  Vulnerabilidades detectadas ou ferramenta reportou output.") false)))))

(defn install-arch-audit [opts]
  (if (:dry-run opts)
    (println "üîç [DRY-RUN] Instalaria arch-audit via pacman.")

    (if (or (:auto opts)
            (do
              (print "‚ùó Deseja instalar 'arch-audit' agora? [s/N] ")
              (flush)
              (= "s" (str/lower-case (str/trim (or (read-line) ""))))))
      (do
        (println "‚öôÔ∏è  Instalando arch-audit...")
        (let [res (shell {:continue true} "sudo pacman -Sy --noconfirm arch-audit")]
          (= 0 (:exit res))))
      (do
        (println "‚è≠Ô∏è  Instala√ß√£o ignorada.")
        false))))

(defn pkgs-7320 [opts]
  ;; O comportamento "fix" aqui √©:
  ;; 1. Garantir que a ferramenta existe
  ;; 2. Rodar a ferramenta e mostrar o output

  (let [installed? (fs/which "arch-audit")]

    (if (not installed?)
      ;; Se n√£o instalado, tenta instalar
      (when (install-arch-audit opts)
        ;; Se instalou com sucesso, chama recursivamente para rodar o audit
        (pkgs-7320 opts))

      ;; Se j√° instalado (ou acabou de instalar)
      (do
        (println "üîé Executando an√°lise com arch-audit...")
        (shell "arch-audit")))))

; NETW-3200: Verifica e desabilita protocolos de rede n√£o utilizados (dccp, sctp, rds, tipc)

(def netw-protocols ["dccp" "sctp" "rds" "tipc"])
(def netw-conf-file "/etc/modprobe.d/block-protocols.conf")

(defn is-module-loaded?
  "Verifica se o m√≥dulo est√° carregado na mem√≥ria (lsmod)."
  [proto]
  (let [res (shell {:out :string :continue true} "lsmod")]
    (if (not= 0 (:exit res))
      false
      (boolean (re-find (re-pattern (str "^" proto "\\b")) (:out res))))))

(defn is-module-disabled-in-file?
  "Verifica se existe a linha 'install proto /bin/true' no arquivo de conf."
  [proto]
  (if-not (fs/exists? netw-conf-file)
    false
    (let [content (slurp netw-conf-file)
          pattern (re-pattern (str "(?m)^\\s*install\\s+" proto "\\s+/bin/true"))]
      (boolean (re-find pattern content)))))

(defn verify-kernel-config
  "Roda modprobe --showconfig para ver se o kernel reconhece o bloqueio."
  [proto]
  (let [res (shell {:out :string :err :null :continue true} "modprobe --showconfig")]
    (if (not= 0 (:exit res))
      false
      (boolean (re-find (re-pattern (str "install\\s+" proto "\\s+/bin/true")) (:out res))))))

(defn netw-3200-check [_opts]
  (println (str "[NETW-3200] Verificando protocolos desnecess√°rios: " (str/join ", " netw-protocols)))

  (let [results (for [proto netw-protocols]
                  (let [loaded    (is-module-loaded? proto)
                        blocked   (is-module-disabled-in-file? proto)]
                    {:proto proto :loaded loaded :blocked blocked}))
        all-ok? (every? (fn [r] (and (:blocked r) (not (:loaded r)))) results)]

    (if all-ok?
      (do
        (println "‚úÖ Todos os protocolos est√£o desabilitados e descarregados.")
        true)
      (do
        (doseq [r results]
          (cond
            (:loaded r)  (println (str "‚ö†Ô∏è  " (:proto r) " est√° carregado na mem√≥ria."))
            (not (:blocked r)) (println (str "‚ùå " (:proto r) " n√£o est√° bloqueado em " netw-conf-file))
            :else (println (str "‚úîÔ∏è  " (:proto r) " ok."))))
        false))))

(defn confirm-netw-unload? [proto]
  (print (str "‚ö†Ô∏è  M√≥dulo " proto " est√° carregado. Deseja descarreg√°-lo agora? [s/N] "))
  (flush)
  (let [input (str/trim (or (read-line) ""))]
    (= "s" (str/lower-case input))))

(defn netw-3200 [opts]
  ;; 1. Configura√ß√£o de Persist√™ncia (Arquivo)
  (let [missing-blocks (remove is-module-disabled-in-file? netw-protocols)]
    (when (seq missing-blocks)
      (if (:dry-run opts)
        (println (str "üîí [DRY-RUN] Adicionaria regras de bloqueio para: " (str/join ", " missing-blocks)))

        (try
          (fs/create-dirs (fs/parent netw-conf-file))
          (when-not (fs/exists? netw-conf-file)
            (spit netw-conf-file "# Criado por hardening NETW-3200\n"))

          (println (str "üìù Atualizando " netw-conf-file "..."))
          (doseq [proto missing-blocks]
            (spit netw-conf-file (str "install " proto " /bin/true\n") :append true)
            (println (str "‚úÖ Adicionada regra de install/bin/true para " proto)))

          (catch Exception e
            (println (str "üî¥ Erro ao escrever arquivo: " (.getMessage e))))))))

  ;; 2. Configura√ß√£o de Runtime (Mem√≥ria)
  (doseq [proto netw-protocols]
    (when (is-module-loaded? proto)
      (cond
        (:dry-run opts)
        (println (str "üõë [DRY-RUN] Executaria 'modprobe -r " proto "'."))

        (or (:auto opts) (confirm-netw-unload? proto))
        (do
          (println (str "‚öôÔ∏è  Removendo m√≥dulo " proto "..."))
          (let [res (shell {:continue true} "sudo modprobe -r" proto)]
            (if (= 0 (:exit res))
              (println "‚úÖ Sucesso.")
              (println "‚ùå Falha ao descarregar (pode estar em uso)."))))

        :else
        (println (str "‚è≠Ô∏è  " proto " permanecer√° carregado at√© reboot.")))))

  ;; 3. Verifica√ß√£o Final do Kernel (modprobe --showconfig)
  ;; Isso confirma se o "install /bin/true" foi absorvido
  (println "\nüß™ Verificando persist√™ncia no kernel (modprobe --showconfig)...")
  (if (:dry-run opts)
    (println "‚ÑπÔ∏è  [DRY-RUN] Verifica√ß√£o pulada.")
    (doseq [proto netw-protocols]
      (if (verify-kernel-config proto)
        (println (str "üîí " proto ": corretamente bloqueado (install /bin/true detectado)."))
        (println (str "‚ö†Ô∏è  " proto ": bloqueio n√£o detectado no showconfig. Talvez precise reiniciar ou rodar 'depmod'."))))))

; PHP-2372: Desativa exposi√ß√£o de vers√£o do PHP via expose_php = Off
; PHP-2376: Desativa allow_url_fopen para evitar downloads remotos via PHP

;; --- Helpers Gen√©ricos para PHP ---

(defn get-php-ini-path
  "Localiza o php.ini ativo via comando 'php --ini'."
  []
  (if-not (fs/which "php")
    nil
    (let [res (shell {:out :string :err :null :continue true} "php --ini")]
      (when (= 0 (:exit res))
        (some->> (str/split-lines (:out res))
                 (filter #(str/includes? % "Loaded Configuration File"))
                 (first)
                 ;; CORRE√á√ÉO: Usamos #(...) para colocar o argumento '%' na primeira posi√ß√£o
                 (#(str/split % #":\s+"))
                 (second)
                 (str/trim))))))

(defn get-php-setting
  "L√™ o valor de uma configura√ß√£o no arquivo ini."
  [ini-path key-name]
  (let [pattern (re-pattern (str "(?i)^\\s*" key-name "\\s*=\\s*(\\w+)"))]
    (some->> (str/split-lines (slurp ini-path))
             (keep #(second (re-find pattern %))) ;; Pega o valor capturado
             (first))))

(defn restart-web-service
  "Tenta reiniciar o servi√ßo web, perguntando ao usu√°rio qual √©."
  [opts]
  (println "üîÅ Deseja reiniciar o servidor web (ex: apache/nginx/php-fpm)? [s/N] ")
  (flush)

  (let [should-restart? (if (:auto opts)
                          true ;; Se √© auto, assumimos que sim, mas precisamos saber qual servi√ßo
                          (= "s" (str/lower-case (str/trim (or (read-line) "")))))]

    (when should-restart?
      (print "Informe o nome do servi√ßo (ex: php-fpm, apache2, nginx): ")
      (flush)
      (let [svc (str/trim (or (read-line) ""))]
        (if (str/blank? svc)
          (println "‚ö†Ô∏è  Nome do servi√ßo vazio. Reinicializa√ß√£o ignorada.")
          (do
            (println (str "‚öôÔ∏è  Reiniciando " svc "..."))
            (if (:dry-run opts)
              (println "‚ÑπÔ∏è  [DRY-RUN] Executaria: sudo systemctl restart" svc)
              (let [res (shell {:continue true} "sudo systemctl restart" svc)]
                (if (= 0 (:exit res))
                  (println (str "‚úÖ Servi√ßo " svc " reiniciado."))
                  (println (str "‚ùå Falha ao reiniciar " svc ".")))))))))))

(defn apply-php-fix
  "L√≥gica comum para aplicar corre√ß√µes no php.ini."
  [opts key-name target-value desc-id]
  (let [ini-path (get-php-ini-path)]
    (if-not ini-path
      (println "‚ùå N√£o foi poss√≠vel localizar o arquivo php.ini (PHP instalado?).")

      (do
        (println (str "üìÑ Usando " ini-path))
        (let [content (slurp ini-path)
              lines   (str/split-lines content)
              pattern (re-pattern (str "(?i)^\\s*" key-name "\\s*="))
              target-line (str key-name " = " target-value)]

          ;; Processa as linhas
          (let [result (reduce (fn [acc line]
                                 (if (re-find pattern line)
                                   (-> acc
                                       (update :lines conj target-line)
                                       (assoc :found true))
                                   (update acc :lines conj line)))
                               {:lines [] :found false}
                               lines)

                final-lines (if (:found result)
                              (:lines result)
                              (concat (:lines result) [(str "\n; Adicionado por hardening " desc-id) target-line]))]

            (if (:dry-run opts)
              (println (str "üîç [DRY-RUN] Definiria " key-name " = " target-value))

              (try
                (spit ini-path (str (str/join "\n" final-lines) "\n"))
                (println (str "‚úÖ " key-name " definido como " target-value "."))
                (restart-web-service opts)
                (catch Exception e
                  (println (str "üî¥ Erro ao escrever no php.ini: " (.getMessage e))))))))))))

;; --- M√≥dulo PHP-2372 ---

(defn php-2372-check [_opts]
  (println "[PHP-2372] Verificando configura√ß√£o expose_php...")
  (if-let [ini-path (get-php-ini-path)]
    (let [val (get-php-setting ini-path "expose_php")]
      (if (= "Off" val) ;; Case sensitive check aqui, ou use str/lower-case se preferir
        (do (println "‚úîÔ∏è  expose_php j√° est√° Off.") true)
        (do (println (str "‚ö†Ô∏è  expose_php est√° configurado como " (or val "N/A"))) false)))
    (do (println "‚ö†Ô∏è  php.ini n√£o encontrado.") false)))

(defn php-2372 [opts]
  (when-not (php-2372-check opts)
    (apply-php-fix opts "expose_php" "Off" "PHP-2372")))

;; --- M√≥dulo PHP-2376 ---

(defn php-2376-check [_opts]
  (println "[PHP-2376] Verificando configura√ß√£o allow_url_fopen...")
  (if-let [ini-path (get-php-ini-path)]
    (let [val (get-php-setting ini-path "allow_url_fopen")]
      (if (= "Off" val)
        (do (println "‚úîÔ∏è  allow_url_fopen j√° est√° Off.") true)
        (do (println (str "‚ö†Ô∏è  allow_url_fopen est√° configurado como " (or val "N/A"))) false)))
    (do (println "‚ö†Ô∏è  php.ini n√£o encontrado.") false)))

(defn php-2376 [opts]
  (when-not (php-2376-check opts)
    (apply-php-fix opts "allow_url_fopen" "Off" "PHP-2376")))

; LOGG-2146: Verifica e rotaciona arquivos de log (incluindo subdiret√≥rios)

(def custom-logrotate-conf "/etc/logrotate.d/custom-unmanaged-logs")

(defn get-all-log-files
  "Encontra todos os arquivos .log em /var/log recursivamente."
  []
  (try
    (->> (fs/glob "/var/log" "**/*.log")
         (map str) ;; Converte Path object para String
         (filter fs/regular-file?) ;; Garante que √© arquivo, n√£o diret√≥rio
         set)
    (catch Exception e
      (println (str "‚ö†Ô∏è  Erro ao listar arquivos em /var/log: " (.getMessage e)))
      #{})))

(defn get-managed-logs
  "L√™ configs do logrotate e retorna um set de caminhos configurados."
  []
  (let [configs (concat ["/etc/logrotate.conf"]
                        (map str (fs/glob "/etc/logrotate.d" "*")))

        extract-path (fn [line]
                       ;; Regex equivalente ao m{^(/var/log/[^ ]+)} do Perl
                       (second (re-find #"^(/var/log/\S+)" (str/trim line))))]

    (->> configs
         (filter fs/exists?)
         (filter fs/regular-file?)
         (mapcat (fn [f]
                   (try
                     (str/split-lines (slurp f))
                     (catch Exception _ []))))
         (keep extract-path)
         set)))

(defn get-unmanaged-logs
  "Retorna lista de logs que existem no disco mas n√£o nas configs."
  []
  (let [all-logs (get-all-log-files)
        managed  (get-managed-logs)]
    ;; Remove do set 'all-logs' aqueles que est√£o em 'managed'
    (sort (vec (clojure.set/difference all-logs managed)))))

(defn logg-2146-check [_opts]
  (println "[LOGG-2146] Verificando rota√ß√£o de logs...")

  (if-not (fs/which "logrotate")
    (do
      (println "‚ùå logrotate n√£o est√° instalado.")
      false)

    (let [unmanaged (get-unmanaged-logs)]
      (if (empty? unmanaged)
        (do
          (println "‚úÖ Todos os arquivos .log em /var/log est√£o sendo rotacionados.")
          true)
        (do
          (println "‚ö†Ô∏è  Arquivos sem rota√ß√£o configurada:")
          (doseq [log unmanaged]
            (println (str "   - " log)))
          false)))))

(defn generate-logrotate-entry [log-path]
  (str log-path " {\n"
       "    weekly\n"
       "    rotate 4\n"
       "    compress\n"
       "    missingok\n"
       "    notifempty\n"
       "}\n"))

(defn logg-2146 [opts]
  ;; Check falhou (logs √≥rf√£os ou sem logrotate)
  (when-not (logg-2146-check opts)

    ;; 1. Verifica instala√ß√£o
    (when-not (fs/which "logrotate")
      (println "üîß Por favor instale com: sudo pacman -S logrotate")
      (throw (ex-info "Depend√™ncia ausente" {:pkg "logrotate"})))

    ;; 2. Trata os logs √≥rf√£os
    (let [unmanaged (get-unmanaged-logs)]
      (when (seq unmanaged)
        (cond
          (:dry-run opts)
          (println "üîç [DRY-RUN] Seriam criadas regras para os arquivos listados acima.")

          (or (:auto opts)
              (do
                (print "Deseja configurar rota√ß√£o padr√£o para esses arquivos? [s/N] ")
                (flush)
                (= "s" (str/lower-case (str/trim (or (read-line) ""))))))
          (try
            (println (str "‚öôÔ∏è  Gerando configura√ß√£o em " custom-logrotate-conf "..."))

            (let [content (str "# Criado automaticamente por hardening LOGG-2146\n"
                               (str/join "\n" (map generate-logrotate-entry unmanaged)))]
              (spit custom-logrotate-conf content))

            (println "‚úÖ Regras de rota√ß√£o criadas com sucesso.")

            (catch Exception e
              (println (str "üî¥ Erro ao criar arquivo de configura√ß√£o: " (.getMessage e)))))

          :else
          (println "‚è≠Ô∏è  Configura√ß√£o ignorada."))))))

; BANN-7126: Adiciona um banner legal em /etc/issue e /etc/issue.net
(def banner-targets ["/etc/issue" "/etc/issue.net"])

(def banner-lines
  ["‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
   "‚ïë        ‚ö†Ô∏è  ACESSO RESTRITO AO SISTEMA ‚ö†Ô∏è              ‚ïë"
   "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
   ""
   "Este sistema √© de uso exclusivo de usu√°rios autorizados."
   ""
   "Todas as atividades s√£o monitoradas e registradas."
   "Usu√°rios n√£o autorizados estar√£o sujeitos a san√ß√µes administrativas,"
   "civis e criminais, conforme a legisla√ß√£o vigente."
   ""
   "Ao continuar, voc√™ declara estar ciente e concorda com esses termos."
   ""])

(def full-banner (str/join "\n" banner-lines))

(defn has-legal-banner?
  "Verifica se o arquivo cont√©m palavras-chave do banner."
  [file]
  (if-not (fs/exists? file)
    false
    (let [content (slurp file)]
      ;; L√≥gica do Perl: grep { /ACESSO RESTRITO|Todas as atividades/ }
      (boolean (re-find #"ACESSO RESTRITO|Todas as atividades" content)))))

(defn bann-7126-check [_opts]
  (println "[BANN-7126] Verificando banner legal em /etc/issue e issue.net...")

  (let [results (for [f banner-targets]
                  {:file f :ok (has-legal-banner? f)})
        all-ok? (every? :ok results)]

    (if all-ok?
      (do
        (println "‚úÖ Banner legal presente em todos os arquivos alvo.")
        true)
      (do
        (doseq [r results]
          (if (:ok r)
            (println (str "‚úîÔ∏è  " (:file r) " j√° possui banner."))
            (println (str "‚ö†Ô∏è  " (:file r) " n√£o possui o banner padr√£o."))))
        false))))

(defn apply-banner [file opts]
  (cond
    (:dry-run opts)
    (do
      (println (str "üîç [DRY-RUN] O seguinte conte√∫do seria escrito em " file ":\n"))
      (println full-banner))

    (or (:auto opts)
        (do
          (print (str "Deseja aplicar o banner legal em " file "? [s/N] "))
          (flush)
          (= "s" (str/lower-case (str/trim (or (read-line) ""))))))
    (try
      (spit file (str full-banner "\n"))
      (println (str "‚úÖ Banner aplicado com sucesso em " file "."))
      (catch Exception e
        (println (str "üî¥ Erro ao escrever em " file ": " (.getMessage e)))))

    :else
    (println (str "‚è≠Ô∏è  Altera√ß√£o ignorada para " file "."))))

(defn bann-7126 [opts]
  ;; Diferente dos outros, aqui iteramos sobre os arquivos na fun√ß√£o fix
  ;; para permitir que o usu√°rio aceite um e negue outro se quiser (modo interativo)

  (println "[BANN-7126] Iniciando aplica√ß√£o de banners...")

  (doseq [file banner-targets]
    (if (has-legal-banner? file)
      (println (str "‚úîÔ∏è  Banner j√° presente em " file "."))

      ;; Se n√£o tem banner, tenta aplicar
      (apply-banner file opts))))

; ACCT-9622: Habilita process accounting no sistema
;; --- Helpers de Pacotes e Servi√ßos ---

(defn install-package [pkg opts]
  (cond
    (:dry-run opts)
    (println (str "üîç [DRY-RUN] Instalaria pacote " pkg "."))

    (or (:auto opts)
        (do
          (print (str "Deseja instalar o pacote " pkg " agora? [s/N] "))
          (flush)
          (= "s" (str/lower-case (str/trim (or (read-line) ""))))))
    (do
      (println (str "‚öôÔ∏è  Instalando " pkg "..."))
      (let [res (shell {:continue true} "sudo pacman -Sy --noconfirm" pkg)]
        (if (= 0 (:exit res))
          (do (println (str "‚úÖ " pkg " instalado.")) true)
          (do (println (str "‚ùå Falha ao instalar " pkg ".")) false))))

    :else
    (do (println "‚ùé Instala√ß√£o cancelada.") false)))

(defn enable-service [svc opts]
  (if (:dry-run opts)
    (println (str "üîç [DRY-RUN] Habilitaria e iniciaria " svc "."))
    (do
      (println (str "üöÄ Ativando " svc "..."))
      (shell "sudo systemctl enable --now" svc)
      (let [res (shell {:out :string :continue true} "systemctl is-active" svc)]
        (if (= "active" (str/trim (:out res)))
          (println (str "‚úÖ " svc " est√° ativo."))
          (println (str "‚ùå " svc " falhou ao iniciar.")))))))

;; --- ACCT-9622: Process Accounting ---

(defn acct-9622-check [_opts]
  (println "[ACCT-9622] Verificando process accounting (acct)...")
  (if (package-installed? "acct")
    (let [res (shell {:out :string :continue true} "accton")]
      ;; O comando 'accton' sem argumentos n√£o imprime status em algumas vers√µes,
      ;; mas em outras imprime "Turning on process accounting...".
      ;; A maneira mais segura de checar no Linux √© ver se o arquivo de log est√° sendo usado
      ;; ou se existe o flag no kernel, mas vamos confiar na exist√™ncia do arquivo de log ativo.
      (if (fs/exists? "/var/log/pacct")
        (do (println "‚úîÔ∏è  Pacote instalado e log /var/log/pacct existe.") true)
        (do (println "‚ö†Ô∏è  Pacote instalado mas log n√£o encontrado.") false)))
    (do (println "‚ö†Ô∏è  Pacote 'acct' n√£o instalado.") false)))

(defn acct-9622 [opts]
  (when-not (acct-9622-check opts)
    (when (or (package-installed? "acct") (install-package "acct" opts))
      (if (:dry-run opts)
        (println "üîç [DRY-RUN] Ativaria o accounting em /var/log/pacct.")

        (let [log-file "/var/log/pacct"]
          (println "üìÇ Configurando arquivo de log...")
          (when-not (fs/exists? log-file)
            (shell "sudo touch" log-file)
            (shell "sudo chown root:root" log-file)
            (shell "sudo chmod 600" log-file))

          (println "Ativando accton...")
          (let [res (shell {:continue true} "sudo accton" log-file)]
            (if (= 0 (:exit res))
              (println (str "‚úÖ Process accounting ativado em " log-file))
              (println "‚ùå Falha ao ativar accton."))))))))


; ACCT-9626: Ativa coleta de contabilidade de sistema com sysstat
(defn acct-9626-check [_opts]
  (println "[ACCT-9626] Verificando sysstat...")
  (if (package-installed? "sysstat")
    (let [res (shell {:out :string :continue true} "systemctl is-active sysstat")]
      (if (= "active" (str/trim (:out res)))
        (do (println "‚úîÔ∏è  sysstat instalado e rodando.") true)
        (do (println "‚ö†Ô∏è  sysstat instalado mas inativo.") false)))
    (do (println "‚ö†Ô∏è  Pacote 'sysstat' n√£o instalado.") false)))

(defn acct-9626 [opts]
  (when-not (acct-9626-check opts)
    (when (or (package-installed? "sysstat") (install-package "sysstat" opts))

      ;; Configura√ß√£o do /etc/default/sysstat (comum em Debian, mas no Arch as vezes √© opcional)
      (let [conf-file "/etc/default/sysstat"]
        (if (fs/exists? conf-file)
          (if (:dry-run opts)
            (println (str "üîç [DRY-RUN] Ajustaria ENABLED=\"true\" em " conf-file))
            (do
              (println (str "üìù Configurando " conf-file "..."))
              ;; Regex replace simples para ativar
              (let [content (slurp conf-file)
                    new-content (if (str/includes? content "ENABLED")
                                  (str/replace content #"ENABLED=\".*\"" "ENABLED=\"true\"")
                                  (str content "\nENABLED=\"true\"\n"))]
                (spit conf-file new-content)
                (println "‚úÖ Configura√ß√£o atualizada."))))
          (println (str "‚ÑπÔ∏è  " conf-file " n√£o encontrado (pode ser padr√£o no Arch). Seguindo para ativa√ß√£o do servi√ßo."))))

      ;; Ativa servi√ßo
      (enable-service "sysstat" opts))))


; ACCT-9628: Ativa auditd e configura regras b√°sicas de auditoria
(defn acct-9628-check [_opts]
  (println "[ACCT-9628] Verificando auditd...")
  (if (package-installed? "audit")
    (let [active? (= "active" (str/trim (:out (shell {:out :string :continue true} "systemctl is-active auditd"))))
          rules-exist? (fs/exists? "/etc/audit/rules.d/99-hardening.rules")]
      (if (and active? rules-exist?)
        (do (println "‚úîÔ∏è  auditd ativo e regras de hardening presentes.") true)
        (do (println "‚ö†Ô∏è  auditd inativo ou sem regras configuradas.") false)))
    (do (println "‚ö†Ô∏è  Pacote 'audit' n√£o instalado.") false)))

(defn acct-9628 [opts]
  (when-not (acct-9628-check opts)
    (when (or (package-installed? "audit") (install-package "audit" opts))

      ;; Ativa servi√ßo PRIMEIRO (auditd precisa estar rodando para carregar regras via augenrules as vezes)
      (enable-service "auditd" opts)

      (if (:dry-run opts)
        (println "üîç [DRY-RUN] Criaria regras de auditoria em /etc/audit/rules.d/99-hardening.rules.")

        (do
          (println "üõ°Ô∏è  Escrevendo regras de auditoria...")
          (let [rules-file "/etc/audit/rules.d/99-hardening.rules"
                rules-content (str "# Regras de Hardening ACCT-9628\n"
                                   "-w /etc/passwd -p wa -k passwd_changes\n"
                                   "-w /etc/shadow -p wa -k shadow_changes\n"
                                   "-w /etc/group -p wa -k group_changes\n"
                                   "-w /etc/sudoers -p wa -k sudoers_changes\n"
                                   "-a always,exit -F path=/usr/bin/passwd -F perm=x -k passwd_exec\n"
                                   "-a always,exit -F path=/usr/bin/sudo -F perm=x -k sudo_exec\n"
                                   "-a always,exit -F path=/usr/bin/chmod -F perm=x -k chmod_exec\n"
                                   "-a always,exit -F path=/usr/bin/chown -F perm=x -k chown_exec\n"
                                   "-a always,exit -F arch=b64 -S chown,fchown,fchownat,lchown -k chown_calls\n"
                                   "-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -k chmod_calls\n")]

            (try
              (spit rules-file rules-content)
              (println "‚úÖ Regras escritas com sucesso.")

              ;; Carrega regras
              (println "üîÑ Carregando regras (augenrules)...")
              (let [res (shell {:continue true} "sudo augenrules --load")]
                (if (= 0 (:exit res))
                  (println "‚úÖ Regras carregadas no kernel.")
                  (println "‚ö†Ô∏è  Falha ao carregar regras (verifique logs do auditd).")))

              (catch Exception e
                (println (str "üî¥ Erro ao escrever regras: " (.getMessage e)))))))))))

; TIME-3104: Ativa sincroniza√ß√£o de tempo com NTP (systemd-timesyncd)
(defn get-ntp-status
  "Obt√©m propriedades NTP do timedatectl de forma estruturada."
  []
  (let [res (shell {:out :string :err :null :continue true}
                   "timedatectl show -p NTP -p NTPSynchronized")]
    (if (not= 0 (:exit res))
      {:active "no" :synced "no"} ;; Falha segura
      (let [lines (str/split-lines (:out res))
            props (into {} (map #(str/split % #"=" 2) lines))]
        {:active (get props "NTP" "no")
         :synced (get props "NTPSynchronized" "no")}))))

(defn time-3104-check [_opts]
  (println "[TIME-3104] Verificando status da sincroniza√ß√£o NTP...")

  (let [status (get-ntp-status)
        is-active (= "yes" (:active status))
        is-synced (= "yes" (:synced status))]

    (if (and is-active is-synced)
      (do
        (println "‚úÖ Sincroniza√ß√£o NTP est√° ativa e o rel√≥gio est√° sincronizado.")
        true)
      (do
        (println "‚ö†Ô∏è  Status do NTP:")
        (println (str "   - Servi√ßo Ativo: " (:active status)))
        (println (str "   - Sincronizado:  " (:synced status)))
        false))))

(defn time-3104 [opts]
  (when-not (time-3104-check opts)

    (cond
      (:dry-run opts)
      (println "üîç [DRY-RUN] Habilitaria e iniciaria systemd-timesyncd.service.")

      (or (:auto opts)
          (do
            (print "Deseja ativar systemd-timesyncd agora? [s/N] ")
            (flush)
            (= "s" (str/lower-case (str/trim (or (read-line) ""))))))
      (do
        (println "üîß Habilitando systemd-timesyncd...")
        ;; Tenta habilitar e iniciar
        (shell {:continue true} "sudo systemctl enable systemd-timesyncd.service")
        (shell {:continue true} "sudo systemctl start systemd-timesyncd.service")

        ;; Aguarda um breve momento para o servi√ßo tentar sync (opcional, mas √∫til)
        (Thread/sleep 1000)

        ;; Verifica√ß√£o p√≥s-ativa√ß√£o
        (let [status (get-ntp-status)]
          (if (= "yes" (:synced status))
            (println "‚úÖ Sincroniza√ß√£o NTP ativada com sucesso.")
            (do
              ;; √Äs vezes demora um pouco para sincronizar, ent√£o verificamos se pelo menos est√° ativo
              (if (= "yes" (:active status))
                (println "‚ö†Ô∏è  Servi√ßo ativado, mas o rel√≥gio ainda est√° sincronizando (pode levar alguns segundos).")
                (println "‚ùå Falha ao ativar sincroniza√ß√£o NTP. Verifique logs do systemd-timesyncd."))))))

      :else
      (println "‚è≠Ô∏è  Ativa√ß√£o ignorada."))))


; CRYP-7902: Verifica certificados locais que est√£o expirados ou prestes a expirar

;; Diret√≥rios padr√£o de certificados no Linux
(def cert-paths ["/etc/ssl"
                 "/etc/pki"
                 "/usr/local/share/ca-certificates"
                 "/etc/letsencrypt/live"
                 "/etc/letsencrypt/archive"])

;; Formatador para ler a data do OpenSSL (Ex: "May  5 12:00:00 2025 GMT")
;; Usamos Locale/US pois o OpenSSL geralmente retorna meses em ingl√™s
(def openssl-date-fmt
  (DateTimeFormatter/ofPattern "MMM d HH:mm:ss yyyy z" Locale/US))

(defn find-cert-files
  "Busca arquivos .crt, .pem, .cer recursivamente nos caminhos definidos."
  []
  (let [extensions #{".crt" ".pem" ".cer"}]
    (->> cert-paths
         (filter fs/exists?) ;; Ignora diret√≥rios que n√£o existem
         (mapcat (fn [path]
                   (try
                     (fs/glob path "**/*.{crt,pem,cer}")
                     (catch Exception _ [])))) ;; Ignora erros de permiss√£o na listagem
         (map str) ;; Converte Path object para String
         (distinct)))) ;; Evita duplicatas (links simb√≥licos podem causar isso)

(defn get-cert-end-date
  "Extrai a data de expira√ß√£o usando openssl."
  [cert-file]
  (let [res (shell {:out :string :err :null :continue true}
                   "openssl x509 -enddate -noout -in" cert-file)]
    (when (= 0 (:exit res))
      (let [out (str/trim (:out res))]
        ;; Output esperado: notAfter=May  5 12:00:00 2025 GMT
        (when-let [[_ date-str] (re-find #"^notAfter=(.*)" out)]
          (try
            ;; As vezes o dia vem com espa√ßo extra "May  5", o parser do Java pode ser estrito
            ;; Vamos normalizar espa√ßos simples
            (let [clean-date (str/join " " (str/split date-str #"\s+"))]
              (ZonedDateTime/parse clean-date openssl-date-fmt))
            (catch Exception e
              (println (str "‚ö†Ô∏è  Erro ao parsear data de " cert-file ": " date-str))
              nil)))))))

(defn check-cert-status
  "Retorna :expired, :expiring ou :ok"
  [cert-file now warn-date]
  (if-let [end-date (get-cert-end-date cert-file)]
    (cond
      (.isBefore end-date now) :expired
      (.isBefore end-date warn-date) :expiring
      :else :ok)
    :error)) ;; Erro ao ler/parsear

(defn cryp-7902-check [_opts]
  (println "[CRYP-7902] Verificando certificados locais para expira√ß√£o...")

  (let [certs (find-cert-files)]
    (if (empty? certs)
      (do
        (println "‚ÑπÔ∏è  Nenhum certificado encontrado nos diret√≥rios padr√£o.")
        true)

      (let [now (ZonedDateTime/now)
            warn-date (.plusDays now 30)

            ;; Processa todos os certificados
            results (pmap (fn [f] ;; pmap faz em paralelo para ser mais r√°pido
                            (assoc {} :file f :status (check-cert-status f now warn-date)))
                          certs)

            expired (filter #(= :expired (:status %)) results)
            expiring (filter #(= :expiring (:status %)) results)]

        ;; Reporta Problemas
        (doseq [r expired]
          (println (str "‚ùå [EXPIRADO] " (:file r))))

        (doseq [r expiring]
          (println (str "‚ö†Ô∏è  [Vencendo em breve] " (:file r))))

        ;; Resumo Final
        (if (and (empty? expired) (empty? expiring))
          (do
            (println "‚úÖ Todos os certificados est√£o v√°lidos por pelo menos 30 dias.")
            true)
          (do
            (println (str "\nResumo: " (count expired) " expirado(s), " (count expiring) " vencendo(s) em at√© 30 dias."))
            false))))))

(defn cryp-7902 [opts]
  ;; Como este m√≥dulo √© apenas de verifica√ß√£o (n√£o renovamos certificados automaticamente
  ;; pois isso depende de CA externa ou LetsEncrypt), a fun√ß√£o principal apenas roda o check.
  (cryp-7902-check opts))

; FINT-4350: Instala e inicializa AIDE para verifica√ß√£o de integridade de arquivos

;; --- FINT-4350: AIDE ---

(defn fint-4350-check [_opts]
  (println "[FINT-4350] Verificando AIDE (File Integrity)...")
  (if (package-installed? "aide")
    (if (fs/exists? "/var/lib/aide/aide.db.gz")
      (do (println "‚úîÔ∏è  AIDE instalado e banco de dados presente.") true)
      (do (println "‚ö†Ô∏è  AIDE instalado mas banco de dados n√£o encontrado.") false))
    (do (println "‚ö†Ô∏è  Pacote 'aide' n√£o instalado.") false)))

(defn fint-4350 [opts]
  (when-not (fint-4350-check opts)

    ;; 1. Instala√ß√£o
    (when (or (package-installed? "aide") (install-package "aide" opts))

      (if (:dry-run opts)
        (println "üîç [DRY-RUN] Inicializaria o banco de dados do AIDE.")

        (do
          (println "üõ†Ô∏è  Inicializando banco de dados do AIDE (pode demorar)...")
          (let [res (shell {:continue true} "sudo aide --init")]
            (if (not= 0 (:exit res))
              (println "‚ùå Falha ao gerar banco de dados.")

              (do
                (println "‚úÖ Banco inicial gerado.")
                (println "üìÇ Movendo banco para local padr√£o...")
                (let [mv-res (shell {:continue true} "sudo mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz")]
                  (if (= 0 (:exit mv-res))
                    (do
                      (println "‚úÖ Banco de dados pronto.")
                      (println "‚ÑπÔ∏è  Execute verifica√ß√µes futuras com: sudo aide --check"))
                    (println "‚ö†Ô∏è  Falha ao mover banco de dados.")))))))))))


; TOOL-5002: Verifica presen√ßa de ferramentas de automa√ß√£o no sistema
(def automation-tools
  {"ansible"   "Ansible"
   "puppet"    "Puppet"
   "salt"      "SaltStack"
   "chef-client" "Chef"
   "cf-agent"  "CFEngine"})

(defn tool-5002-check [_opts]
  (println "[TOOL-5002] Verificando ferramentas de automa√ß√£o...")
  (let [found (filter #(fs/which (key %)) automation-tools)]
    (if (seq found)
      (do
        (println "‚úÖ Ferramentas de automa√ß√£o detectadas:")
        (doseq [[bin name] found]
          (println (str "   - " name " (" bin ")")))
        true)
      (do
        (println "‚ö†Ô∏è  Nenhuma ferramenta de automa√ß√£o encontrada.")
        false))))

(defn tool-5002 [opts]
  (when-not (tool-5002-check opts)
    ;; Se n√£o encontrou nada, sugere instalar Ansible
    (install-package "ansible" opts)))

; FILE-7524: Verifica e restringe permiss√µes perigosas de arquivos

(defn get-file-mode
  "Retorna permiss√£o octal como string (ex: '755')."
  [path]
  (try
    (let [path-obj (fs/path path)
          ;; L√™ o atributo 'unix:mode' diretamente do sistema de arquivos
          ;; Isso retorna um inteiro contendo tipo do arquivo + permiss√µes
          attr (Files/getAttribute path-obj "unix:mode" (make-array LinkOption 0))

          ;; Fazemos um bit-and com 0777 (octal) para pegar apenas os bits de permiss√£o (rwx)
          ;; e ignorar os bits que dizem se √© arquivo, diret√≥rio ou link.
          octal (format "%o" (bit-and attr 0777))]
      octal)
    (catch Exception _ nil)))

(defn get-risky-files
  "Busca arquivos com permiss√µes 777, 666."
  []
  ;; Limitamos a busca para evitar scan do disco inteiro
  ;; e usamos max-depth para n√£o travar em /var/lib/docker e afins.
  (let [base-dirs ["/etc" "/home" "/opt" "/srv"] ;; Removi /var pois √© muito grande/ruidoso
        suspects (atom [])]

    (doseq [dir base-dirs]
      (when (fs/exists? dir)
        ;; fs/glob √© recursivo. Cuidado.
        ;; Para performance e seguran√ßa, vamos iterar manualmente com fs/walk limitando profundidade seria ideal,
        ;; mas glob "**" √© o padr√£o. Vamos filtrar depois.
        (try
          (doseq [f (fs/glob dir "**/*")]
            (when (fs/regular-file? f)
              (let [mode (get-file-mode f)]
                (when (or (= "777" mode) (= "666" mode))
                  (let [name (str f)
                        type (cond
                               (re-find #"\.(conf|ini)$" name) :config
                               (re-find #"\.(key|pem)$" name) :key
                               (re-find #"id_rsa" name) :key
                               :else :file)]
                    (swap! suspects conj {:path name :mode mode :type type}))))))
          (catch Exception e
            (println (str "‚ö†Ô∏è  Erro ao escanear " dir ": " (.getMessage e)))))))
    @suspects))

(defn suggest-mode [{:keys [mode type]}]
  (cond
    (= :key type) "600"
    (= :config type) "640"
    (= "777" mode) "755" ;; Execut√°vel p√∫blico -> Execut√°vel seguro
    (= "666" mode) "644" ;; Leitura/Escrita p√∫blica -> Leitura p√∫blica
    :else "644"))

(defn file-7524-check [_opts]
  (println "[FILE-7524] Buscando arquivos com permiss√µes perigosas (777/666)...")
  (let [files (get-risky-files)]
    (if (seq files)
      (do
        (println (str "‚ö†Ô∏è  Encontrados " (count files) " arquivos arriscados:"))
        (doseq [f (take 10 files)]
          (println (str "   [" (:mode f) "] " (:path f))))
        (when (> (count files) 10) (println "..."))
        false)
      (do
        (println "‚úÖ Nenhum arquivo cr√≠tico encontrado (nos diret√≥rios base).")
        true))))

(defn file-7524 [opts]
  (when-not (file-7524-check opts)
    (let [files (get-risky-files)]

      (cond
        (:dry-run opts)
        (do
          (println "üîç [DRY-RUN] Sugest√µes de corre√ß√£o:")
          (doseq [f (take 20 files)]
            (println (str "chmod " (suggest-mode f) " " (:path f)))))

        (or (:auto opts)
            (do
              (print "Deseja corrigir as permiss√µes automaticamente? [s/N] ")
              (flush)
              (= "s" (str/lower-case (str/trim (or (read-line) ""))))))
        (do
          (println "üõ†Ô∏è  Aplicando corre√ß√µes...")
          (doseq [f files]
            (let [new-mode (suggest-mode f)]
              (try
                (fs/set-posix-file-permissions (:path f) new-mode)
                (println (str "‚úÖ " (:path f) " -> " new-mode))
                (catch Exception e
                  ;; Tenta com sudo se falhar (fs/set-posix usa Java API que roda como usu√°rio atual)
                  (let [res (shell {:continue true} "sudo chmod" new-mode (:path f))]
                    (if (= 0 (:exit res))
                      (println (str "‚úÖ [SUDO] " (:path f) " -> " new-mode))
                      (println (str "‚ùå Falha: " (:path f))))))))))

        :else
        (println "‚è≠Ô∏è  Corre√ß√µes ignoradas.")))))

; KRNL-6000: Aplica valores seguros de sysctl para seguran√ßa do kernel com backup

;; --- KRNL-6000: Sysctl Hardening ---

(def sysctl-recommended
  {"kernel.kptr_restrict" "2"
   "fs.suid_dumpable" "0"
   "kernel.randomize_va_space" "2"
   "net.ipv4.icmp_echo_ignore_broadcasts" "1"
   "net.ipv4.conf.all.accept_redirects" "0"
   "net.ipv4.conf.all.send_redirects" "0"
   "net.ipv4.conf.all.accept_source_route" "0"
   "net.ipv4.conf.default.accept_redirects" "0"
   "net.ipv4.conf.default.send_redirects" "0"
   "net.ipv4.conf.default.accept_source_route" "0"
   "net.ipv4.tcp_syncookies" "1"
   "net.ipv4.tcp_timestamps" "0"
   "net.ipv6.conf.all.accept_redirects" "0"
   "net.ipv6.conf.default.accept_redirects" "0"})

(defn get-sysctl [key]
  (let [res (shell {:out :string :err :null :continue true} "sysctl -n" key)]
    (if (= 0 (:exit res))
      (str/trim (:out res))
      nil)))

(defn krnl-6000-check [_opts]
  (println "[KRNL-6000] Verificando par√¢metros sysctl...")

  (let [results (for [[k expected] sysctl-recommended]
                  (let [current (get-sysctl k)]
                    {:key k :current current :expected expected :ok? (= current expected)}))
        bad-params (filter #(not (:ok? %)) results)]

    (if (empty? bad-params)
      (do (println "‚úîÔ∏è  Todos os par√¢metros sysctl est√£o corretos.") true)
      (do
        (doseq [p bad-params]
          (println (str "‚ö†Ô∏è  " (:key p) " atual: " (or (:current p) "N/A") " -> recomendado: " (:expected p))))
        false))))

(defn krnl-6000 [opts]
  (when-not (krnl-6000-check opts)
    (let [diffs (filter (fn [[k expected]] (not= (get-sysctl k) expected)) sysctl-recommended)]

      (if (:dry-run opts)
        (do
          (println "üîç [DRY-RUN] Os seguintes valores seriam aplicados:")
          (doseq [[k v] diffs] (println (str "   " k " = " v))))

        (if (or (:auto opts)
                (do
                  (print "Deseja aplicar os valores recomendados e salvar backup? [s/N] ")
                  (flush)
                  (= "s" (str/lower-case (str/trim (or (read-line) ""))))))
          (do
            ;; 1. Backup
            (let [backup-dir "/var/backups"
                  timestamp  (.format (LocalDateTime/now) (DateTimeFormatter/ofPattern "yyyyMMdd"))
                  backup-file (str backup-dir "/sysctl-backup-" timestamp ".conf")]

              (println "üíæ Gerando backup...")
              (fs/create-dirs backup-dir)
              (with-open [w (clojure.java.io/writer backup-file)]
                (.write w (str "# Backup autom√°tico sysctl " timestamp "\n"))
                (doseq [[k _] sysctl-recommended]
                  (when-let [curr (get-sysctl k)]
                    (.write w (str k " = " curr "\n")))))
              (println (str "‚úÖ Backup salvo em " backup-file)))

            ;; 2. Aplica√ß√£o Persistente
            (println "‚öôÔ∏è  Aplicando configura√ß√µes...")
            (let [conf-file "/etc/sysctl.d/99-hardening.conf"
                  new-content (str "# sysctl hardening - KRNL-6000\n"
                                   (str/join "\n" (map (fn [[k v]] (str k " = " v)) diffs))
                                   "\n")]
              (spit conf-file new-content)

              ;; 3. Aplica√ß√£o em Runtime
              (doseq [[k v] diffs]
                (shell "sudo sysctl -w" (str k "=" v)))

              (println (str "‚úÖ Valores aplicados e salvos em " conf-file))))

          (println "‚è≠Ô∏è  Altera√ß√µes ignoradas."))))))


; HRDN-7222: Verifica e restringe o uso de compiladores no sistema

(def compilers ["gcc" "g++" "clang" "cc" "c++" "rustc" "go" "javac"
                "kotlinc" "native-image" "julia" "gfortran" "ifort"
                "nim" "ghc" "fpc" "swiftc" "zig" "v" "nasm" "as"])

(defn get-file-owner [path]
  (try
    (Files/getOwner (fs/path path) (make-array LinkOption 0))
    (catch Exception _ nil)))

(defn get-octal-mode [path]
  (try
    (let [attr (Files/getAttribute (fs/path path) "unix:mode" (make-array LinkOption 0))]
      (format "%o" (bit-and attr 0777))) ;; M√°scara para pegar apenas permiss√µes
    (catch Exception _ nil)))

(defn find-compilers
  "Busca compiladores no PATH e em diret√≥rios espec√≠ficos."
  []
  (let [found (atom #{})]
    ;; 1. Check PATH
    (doseq [c compilers]
      (when-let [p (fs/which c)]
        (swap! found conj (str (fs/real-path p))))) ;; Resolve symlinks

    ;; 2. Scan dirs (limitado para performance)
    ;; No Perl era File::Find. Aqui usamos fs/walk mas com filtro de nome para ser r√°pido.
    (let [search-dirs ["/usr/local" "/opt" "/home"]]
      (doseq [dir search-dirs]
        (when (fs/exists? dir)
          (try
            (fs/walk-file-tree dir
                               {:max-depth 4 ;; Limita profundidade para n√£o varrer o mundo
                                :visit-file (fn [path _attrs]
                                              (let [fname (str (fs/file-name path))]
                                                (when (some #{fname} compilers)
                                                  (swap! found conj (str path)))
                                                :continue))})
            (catch Exception _ nil)))))
    @found))

(defn check-compiler-perms [path]
  (let [mode  (get-octal-mode path)
        owner (str (get-file-owner path)) ;; Retorna Principal, convertemos pra string

        ;; Verifica se √© dono do pr√≥prio home
        home-owner (second (re-find #"^/home/([^/]+)" path))
        is-home-owner? (and home-owner (= owner home-owner))

        ;; Regras de seguran√ßa:
        ;; 1. Root com permiss√£o restrita (750 ou 700 - come√ßa com 7 e termina com 0)
        ;; 2. Ou usu√°rio dono do arquivo dentro da sua home
        is-safe? (or (and (= "root" owner)
                          (re-matches #"7[0-5]0" (str mode)))
                     is-home-owner?)]

    {:path path :mode mode :owner owner :safe? is-safe?}))

(defn hrdn-7222-check [_opts]
  (println "[HRDN-7222] Verificando compiladores...")
  (let [paths (find-compilers)]
    (if (empty? paths)
      (do (println "‚úÖ Nenhum compilador encontrado.") true)

      (let [analysis (map check-compiler-perms paths)
            unsafe   (filter #(not (:safe? %)) analysis)]

        (doseq [item analysis]
          (println (str " - " (:path item) " [" (:mode item) " " (:owner item) "] "
                        (if (:safe? item) "‚úîÔ∏è OK" "‚ùå N√ÉO SEGURO"))))

        (if (empty? unsafe)
          (do (println "‚úÖ Todos os compiladores t√™m permiss√µes seguras.") true)
          (do (println "‚ö†Ô∏è  Compiladores com permiss√µes excessivas detectados.") false))))))

(defn hrdn-7222 [opts]
  (when-not (hrdn-7222-check opts)
    (let [paths (find-compilers)
          unsafe (filter #(not (:safe? (check-compiler-perms %))) paths)]

      (if (:dry-run opts)
        (do
          (println "üîç [DRY-RUN] A√ß√µes sugeridas:")
          (doseq [p unsafe]
            (let [owner (or (second (re-find #"^/home/([^/]+)" p)) "root")]
              (println (str "chmod 750 " p "; chown " owner ":" owner " " p)))))

        (if (or (:auto opts)
                (do
                  (print "Deseja corrigir permiss√µes automaticamente? [s/N] ")
                  (flush)
                  (= "s" (str/lower-case (str/trim (or (read-line) ""))))))
          (doseq [p unsafe]
            (let [owner (or (second (re-find #"^/home/([^/]+)" p)) "root")]
              (println (str "üõ†Ô∏è  Corrigindo " p " -> " owner ":750"))
              (shell "sudo chmod 750" p)
              (shell "sudo chown" (str owner ":" owner) p)))

          (println "‚è≠Ô∏è  Corre√ß√µes ignoradas."))))))

; HRDN-7230: Instala scanner de malware (rkhunter) e executa verifica√ß√£o inicial

;; --- HRDN-7230: Rkhunter ---

(defn hrdn-7230-check [_opts]
  (println "[HRDN-7230] Verificando presen√ßa de scanner de malware...")

  (let [has-rkhunter   (fs/which "rkhunter")
        has-chkrootkit (fs/which "chkrootkit")]

    (if (or has-rkhunter has-chkrootkit)
      (do
        (println (str "‚úÖ Scanner detectado: "
                      (when has-rkhunter "rkhunter ")
                      (when has-chkrootkit "chkrootkit")))
        true)
      (do
        (println "‚ö†Ô∏è  Nenhum scanner (rkhunter/chkrootkit) encontrado.")
        false))))

(defn configure-cron-job [opts]
  (if (:dry-run opts)
    (println "üîç [DRY-RUN] Criaria script em /etc/cron.daily/rkhunter.")

    (if (or (:auto opts)
            (do
              (print "Deseja configurar verifica√ß√£o peri√≥dica (cron daily)? [s/N] ")
              (flush)
              (= "s" (str/lower-case (str/trim (or (read-line) ""))))))
      (try
        (let [cron-path "/etc/cron.daily/rkhunter"
              cron-content (str "#!/bin/sh\n"
                                "/usr/bin/rkhunter --update > /dev/null\n"
                                "/usr/bin/rkhunter --check --skip-keypress --report-warnings-only | tee /var/log/rkhunter-cron.log\n")]

          (println (str "üìÖ Configurando cron job em " cron-path "..."))

          ;; Escreve o arquivo
          (spit cron-path cron-content)

          ;; Torna execut√°vel (precisa ser root, usamos shell chmod para garantir)
          (shell "sudo chmod +x" cron-path)

          (println "‚úÖ Cron di√°rio criado com sucesso."))
        (catch Exception e
          (println (str "üî¥ Erro ao configurar cron: " (.getMessage e)))))

      (println "‚è≠Ô∏è  Configura√ß√£o de cron ignorada."))))

(defn hrdn-7230 [opts]
  ;; 1. Check & Install
  (when-not (hrdn-7230-check opts)
    (when-not (install-package "rkhunter" opts)
      ;; Se falhar ou cancelar instala√ß√£o, aborta o resto da fun√ß√£o
      (println "üõë Abortando configura√ß√£o do rkhunter.")
      ()))
        ;; return n√£o existe em clojure como statement, o when-not cuida do fluxo

  ;; Se chegamos aqui, rkhunter est√° instalado (ou estava, ou acabamos de instalar)
  ;; Mas precisamos garantir que ele est√° instalado para rodar os comandos, caso o check tenha passado por causa do chkrootkit
  (when (fs/which "rkhunter")

    (if (:dry-run opts)
      (println "üîç [DRY-RUN] Executaria atualiza√ß√£o de base, propupd e scan inicial.")

      (do
        (println "üîÑ Atualizando base de dados do rkhunter (pode demorar)...")
        ;; Usamos :continue true pois rkhunter pode retornar warnings como exit code n√£o zero
        (shell {:continue true} "sudo rkhunter --update")

        (println "üì∏ Atualizando propriedades de arquivos (baseline)...")
        (shell {:continue true} "sudo rkhunter --propupd")

        (println "üîç Executando verifica√ß√£o inicial...")
        (shell {:continue true} "sudo rkhunter --check --skip-keypress")

        ;; Configura√ß√£o do Cron
        (configure-cron-job opts)))))

; SSH-7408: Harden SSH configuration

(def ssh-config-file "/etc/ssh/sshd_config")
(def ssh-backup-file "/etc/ssh/sshd_config.bak")

(def base-hardening-config
  {"AllowTcpForwarding"   "no"
   "ClientAliveCountMax"  "2"
   "LogLevel"             "VERBOSE"
   "MaxAuthTries"         "3"
   "MaxSessions"          "2"
   "TCPKeepAlive"         "no"
   "X11Forwarding"        "no"
   "AllowAgentForwarding" "no"})

(defn ask-for-port
  "Determina se a porta deve ser alterada baseada em args ou input."
  [opts]
  ;; 1. Se foi passado via flag --port no main (opts)
  (if-let [cli-port (:port opts)]
    cli-port

    ;; 2. Se for auto sem flag, n√£o muda
    (if (:auto opts)
      nil

      ;; 3. Interativo
      (do
        (print "Deseja alterar a porta padr√£o SSH? [s/N] ")
        (flush)
        (let [resp (str/trim (or (read-line) ""))]
          (when (= "s" (str/lower-case resp))
            (print "Digite a nova porta desejada (ex: 2222): ")
            (flush)
            (let [p (str/trim (or (read-line) ""))]
              (if (re-matches #"\d+" p)
                p
                (do (println "‚ùå Porta inv√°lida. Mantendo a atual.") nil)))))))))

(defn apply-ssh-changes
  "Recebe o conte√∫do do arquivo e um mapa de configura√ß√µes.
   Retorna o novo conte√∫do do arquivo."
  [content settings]
  (let [lines (str/split-lines content)

        ;; Passo 1: Substituir linhas existentes
        ;; Usamos reduce para reconstruir o vetor de linhas e marcar quais chaves encontramos
        processed (reduce (fn [acc line]
                            (let [trimmed (str/trim line)
                                  ;; Tenta achar se a linha come√ßa com alguma chave desejada
                                  ;; Regex: ^\s*Key\s+ (ignora coment√°rios #Key)
                                  matched-key (some (fn [k]
                                                      (when (re-find (re-pattern (str "(?i)^\\s*" k "\\b")) trimmed)
                                                        k))
                                                    (keys settings))]

                              (if matched-key
                                ;; Se achou, substitui a linha pelo valor novo e marca como encontrada
                                (-> acc
                                    (update :lines conj (str matched-key " " (get settings matched-key)))
                                    (update :found conj matched-key))
                                ;; Se n√£o, mant√©m a linha original
                                (update acc :lines conj line))))
                          {:lines [] :found #{}}
                          lines)

        found-keys (:found processed)
        existing-lines (:lines processed)

        ;; Passo 2: Adicionar chaves que n√£o existiam no arquivo
        missing-keys (remove found-keys (keys settings))
        new-lines (map #(str % " " (get settings %)) missing-keys)]

    (str (str/join "\n" (concat existing-lines new-lines)) "\n")))

(defn ssh-7408 [opts]
  (println "[SSH-7408] Endurecendo configura√ß√µes de SSH...")

  (if-not (fs/exists? ssh-config-file)
    (println (str "‚ùå Arquivo " ssh-config-file " n√£o encontrado."))

    (do
      ;; 1. Backup
      (if (and (not (:dry-run opts)) (not (:auto opts)))
        (do
          (print (str "Deseja criar um backup de " ssh-config-file "? [S/n] "))
          (flush)
          (let [resp (str/trim (or (read-line) ""))]
            (when-not (= "n" (str/lower-case resp))
              (shell "cp" ssh-config-file ssh-backup-file)
              (println (str "üì¶ Backup criado em " ssh-backup-file)))))
        ;; Em auto mode, backup autom√°tico √© uma boa pr√°tica, mas seguindo l√≥gica original:
        nil)

      ;; 2. Determinar configura√ß√µes finais
      (let [target-port (ask-for-port opts)
            ;; Se user definiu porta, adiciona ao mapa. Se n√£o, usa o mapa base.
            final-config (if target-port
                           (assoc base-hardening-config "Port" target-port)
                           base-hardening-config)

            content (slurp ssh-config-file)
            new-content (apply-ssh-changes content final-config)]

        ;; 3. Aplica√ß√£o ou Simula√ß√£o
        (if (:dry-run opts)
          (do
            (println "üîç [DRY-RUN] As seguintes configura√ß√µes seriam aplicadas:")
            (doseq [[k v] final-config]
              (println (str "   " k " " v)))
            (println "--- Preview do final do arquivo ---")
            (println (str/join "\n" (take-last 5 (str/split-lines new-content)))))

          (do
            ;; Escrita
            (spit ssh-config-file new-content)
            (println "‚úÖ sshd_config atualizado com sucesso.")

            ;; Restart do servi√ßo
            (if (or (:auto opts)
                    (do
                      (print "Deseja reiniciar o sshd agora? [s/N] ")
                      (flush)
                      (= "s" (str/lower-case (str/trim (or (read-line) ""))))))
              (do
                (println "üîÅ Reiniciando sshd...")
                (let [res (shell {:continue true} "sudo systemctl restart sshd")]
                  (if (= 0 (:exit res))
                    (println "‚úÖ Servi√ßo sshd reiniciado.")
                    (println "‚ùå Falha ao reiniciar sshd."))))
              (println "‚è≠Ô∏è  Restart ignorado."))))))))

;; Entrypoint
(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))
