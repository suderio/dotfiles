#!/usr/bin/env bb

(require '[clojure.string :as str])
(require '[babashka.process :refer [shell process]]
         '[clojure.string :as str])

;; --- Configura√ß√£o do Registro ---
;; Aqui unificamos a descri√ß√£o e o mapeamento.
;; As fun√ß√µes (:fix e :check) ser√£o resolvidas dinamicamente baseadas na chave.
(def registry
  {"boot_5264"           {:desc "An√°lise de seguran√ßa dos servi√ßos systemd"}
   "krnl_5820"           {:desc "Desativa core dumps via limits.conf"}
   "auth_9230"           {:desc "Configura hashing rounds para senhas"}
   "auth_9262"           {:desc "Instala m√≥dulo PAM de for√ßa de senha"}
   "auth_9282"           {:desc "Define data de expira√ß√£o para contas"}
   "auth_9286"           {:desc "Configura idade m√≠nima/m√°xima de senha"}
   "auth_9328"           {:desc "Define umask padr√£o mais restrito (027)"}
   "file_6354"           {:desc "Verifica arquivos antigos em /tmp"}
   "usb_1000"            {:desc "Desativa armazenamento USB"}
   "usb_1000_restore"    {:desc "Reativa armazenamento USB"}
   "strg_1846"           {:desc "Desativa suporte a FireWire"}
   "name_4028"           {:desc "Verifica e ajusta dom√≠nio DNS do sistema"}
   "pkgs_7312"           {:desc "Atualiza pacotes (rolling updates)"}
   "pkgs_7320"           {:desc "Instala `arch-audit` para vulnerabilidades"}
   "netw_3200"           {:desc "Desativa protocolos desnecess√°rios (dccp, etc)"}
   "unblock_net_protocols" {:desc "Reativa protocolos desativados"}
   "ssh_7408"            {:desc "Aplica hardening na configura√ß√£o do SSH"}
   "php_2372"            {:desc "Desativa expose_php no php.ini"}
   "php_2376"            {:desc "Desativa allow_url_fopen no php.ini"}
   "logg_2146"           {:desc "Configura rota√ß√£o de logs em /var/log"}
   "bann_7126"           {:desc "Adiciona banner legal ao /etc/issue e issue.net"}
   "acct_9622"           {:desc "Ativa process accounting (accton)"}
   "acct_9626"           {:desc "Ativa coleta com sysstat (sar, iostat)"}
   "acct_9628"           {:desc "Ativa auditd e regras b√°sicas"}
   "acct_report"         {:desc "Relat√≥rio de contabilidade de processos"}
   "audit_report"        {:desc "Relat√≥rio dos eventos de auditd"}
   "time_3104"           {:desc "Ativa sincroniza√ß√£o com systemd-timesyncd"}
   "cryp_7902"           {:desc "Verifica expira√ß√£o de certificados SSL"}
   "fint_4350"           {:desc "Instala AIDE e inicializa integridade de arquivos"}
   "fint_schedule"       {:desc "Agendamento de verifica√ß√£o do AIDE"}
   "tool_5002"           {:desc "Verifica presen√ßa de ferramentas de automa√ß√£o"}
   "file_7524"           {:desc "Corrige permiss√µes inseguras de arquivos"}
   "krnl_6000"           {:desc "Aplica sysctl seguros e gera backup"}
   "krnl_6000_restore"   {:desc "Restaura sysctl a partir de backup salvo"}
   "hrdn_7222"           {:desc "Restringe uso de compiladores por usu√°rios"}
   "hrdn_7222_prune"     {:desc "Remove compiladores n√£o autorizados"}
   "hrdn_7230"           {:desc "Instala e agenda scanner com rkhunter"}})

;; --- Helpers de Resolu√ß√£o ---

(defn to-symbol [action-name suffix]
  "Converte 'boot_5264' em symbol 'boot-5264' (ou 'boot-5264-check')."
  (let [kebab-name (str/replace action-name "_" "-")
        full-name (if suffix (str kebab-name "-" suffix) kebab-name)]
    (symbol full-name)))

(defn resolve-fn [action-name type]
  "Tenta encontrar a fun√ß√£o no namespace atual."
  (let [func-sym (to-symbol action-name (when (= type :check) "check"))
        f (resolve func-sym)]
    (if f
      f
      (throw (ex-info (str "Fun√ß√£o n√£o implementada: " func-sym) {:fn func-sym})))))

(defn print-help []
  (println "\nüîê Arch Linux Hardening Script (Babashka Port)")
  (println "Uso: bb main.clj <a√ß√£o> [--dry-run] [--auto] [--check-only]\n")
  (println "A√ß√µes dispon√≠veis:")
  (doseq [k (sort (keys registry))]
    (println (format "  %-25s %s" k (get-in registry [k :desc]))))
  (println "\nUse --dry-run para simular e --auto para execu√ß√£o sem perguntas.")
  (System/exit 0))

;; --- Fun√ß√£o Main ---

(defn -main [& args]
  (let [args-set (set args)
        ;; Identifica a a√ß√£o (o primeiro argumento que n√£o come√ßa com --)
        action (first (remove #(str/starts-with? % "--") args))

        options {:dry-run    (contains? args-set "--dry-run")
                 :auto       (contains? args-set "--auto")
                 :check-only (contains? args-set "--check-only")}]

    (cond
      (or (nil? action)
          (contains? args-set "--help")
          (contains? args-set "-h"))
      (print-help)

      (not (contains? registry action))
      (do
        (println (str "‚ùå A√ß√£o desconhecida: " action))
        (println "Use --help para listar as a√ß√µes dispon√≠veis.")
        (System/exit 1))

      :else
      (try
        (println (str "üöÄ Iniciando m√≥dulo: " action))

        ;; L√≥gica da nova arquitetura:
        ;; 1. Resolvemos as fun√ß√µes baseadas no nome da string (snake -> kebab)
        (let [fn-fix   (resolve-fn action :fix)
              fn-check (resolve-fn action :check)]

          ;; Se o usu√°rio pediu apenas check, ou se estamos rodando o fix normal
          ;; Aqui voc√™ pode decidir a l√≥gica. Por exemplo:
          ;; O padr√£o do script Perl era rodar a corre√ß√£o.

          (if (:check-only options)
            (if (fn-check options)
              (println "‚úÖ Verifica√ß√£o OK")
              (println "‚ö†Ô∏è  Verifica√ß√£o FALHOU (A√ß√£o necess√°ria)"))

            ;; Fluxo padr√£o: Executar a corre√ß√£o
            (fn-fix options)))

      (catch Exception e
        (println (str "\nüî¥ Erro cr√≠tico: " (.getMessage e)))
        ;; (println (ex-data e)) ;; Descomente para debug
        (System/exit 1))))))

(defn get-running-services []
  "Retorna uma lista de nomes de servi√ßos ativos (ex: sshd.service)."
  (let [res (shell {:out :string} "systemctl list-units --type=service --state=running --no-legend --plain")
        lines (str/split-lines (:out res))]
    (->> lines
         (map #(first (str/split % #"\s+"))) ;; Pega a primeira coluna
         (filter #(str/ends-with? % ".service"))))) ;; Garante que √© .service

(defn boot-5264-check [_opts]
  (println "üîç [BOOT-5264] Verificando pontua√ß√£o de seguran√ßa global...")

  ;; systemd-analyze security sem argumentos lista todos os servi√ßos com score
  ;; Formato: UNIT EXPOSURE PREDICATE HAPPY
  (let [res (shell {:out :string :continue true} "systemd-analyze security --no-pager")
        lines (drop 1 (str/split-lines (:out res))) ;; Remove cabe√ßalho
        threshold 5.0] ;; Defina seu limiar de toler√¢ncia aqui

    (if (not= 0 (:exit res))
      (do
        (println "‚ö†Ô∏è  systemd-analyze n√£o encontrado ou falhou.")
        false) ;; Falha se n√£o conseguir rodar

      (let [risky-services (->> lines
                                (map (fn [line]
                                       (let [parts (str/split (str/trim line) #"\s+")
                                             unit  (first parts)
                                             score (try (Double/parseDouble (nth parts 1))
                                                        (catch Exception _ 0.0))]
                                         {:unit unit :score score})))
                                (filter #(> (:score %) threshold)))]

        (if (seq risky-services)
          (do
            (println (str "‚ùå Encontrados " (count risky-services) " servi√ßos com exposi√ß√£o > " threshold))
            ;; Retorna false para indicar que a verifica√ß√£o falhou e o 'fix' deve rodar
            false)
          (do
            (println "‚úÖ Todos os servi√ßos est√£o dentro dos limites de seguran√ßa.")
            true))))))

(defn boot-5264 [opts]
  (println "\n[BOOT-5264] Iniciando an√°lise detalhada (Hardening System Services)...")

  (let [services (get-running-services)]
    (println (str "‚ÑπÔ∏è  Servi√ßos identificados: " (count services)))

    (doseq [service services]
      (println (str "\nüîç Analisando seguran√ßa detalhada de: " service))
      ;; Aqui replicamos o comportamento do Perl: rodar a an√°lise detalhada por servi√ßo
      ;; Usamos :continue true pois alguns servi√ßos podem dar erro de permiss√£o ou n√£o suportar an√°lise
      (let [res (shell {:out :string :continue true} "systemd-analyze" "security" service)]
        (println (:out res)))))

  (println "\n[BOOT-5264] An√°lise conclu√≠da.")
  (println "üëâ A√ß√£o recomendada: Revise os servi√ßos acima com pontua√ß√£o 'UNSAFE' e adicione diretivas de sandboxing (ex: ProtectSystem, PrivateTmp) nos unit files."))














;; Entrypoint
(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))
