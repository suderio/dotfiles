#!/usr/bin/env bb

(require '[babashka.process :refer [shell process]]
         '[babashka.fs :as fs]
         '[clojure.string :as str]
         '[clojure.java.io :as io])

;; --- Helpers ---

(defn log [msg]
  (println (str "\nüü¢ \033[1;32m" msg "\033[0m")))

(defn err [msg]
  (println (str "\nüî¥ \033[1;31m" msg "\033[0m")))

(def home (str (fs/home)))

;; --- 1. Criando nossa pr√≥pria "Lib" Git (Wrapper) ---

(defn git-cmd [opts & args]
  (let [base-cmd ["git"]
        base-cmd (if (:git-dir opts)
                   (concat base-cmd ["--git-dir" (:git-dir opts)])
                   base-cmd)
        base-cmd (if (:work-tree opts)
                   (concat base-cmd ["--work-tree" (:work-tree opts)])
                   base-cmd)
        full-cmd (concat base-cmd args)

        proc-opts (merge {:out :string :err :string :continue true}
                         (select-keys opts [:dir]))]

    (let [res (apply shell proc-opts full-cmd)]

      (when (not (str/blank? (:err res)))
        (println (str "‚ö†Ô∏è  Git output: " (str/trim (:err res)))))

      (when (and (not (:continue opts))
                 (not= 0 (:exit res)))
        (throw (ex-info "Erro Cr√≠tico no Git" {:cmd full-cmd :error (:err res)})))

      res)))

(defmulti git (fn [action & _] action))

(defmethod git :pull [_ opts]
  (println "‚¨áÔ∏è Git Pull...")
  (git-cmd opts "pull"))

(defmethod git :push [_ opts]
  (println "‚¨ÜÔ∏è Git Push...")
  (git-cmd opts "push"))

(defmethod git :add [_ opts files]
  (when (seq files)
    (println (str "‚ûï Adicionando: " (str/join ", " files)))
    (apply git-cmd opts "add" files)))

(defmethod git :commit [_ opts msg]
  (println "üíæ Git Commit...")
  ;; :continue true pois o commit falha se nada mudou
  (git-cmd (assoc opts :continue true) "commit" "-m" msg))

(defmethod git :status-porcelain [_ opts]
  (let [res (git-cmd opts "status" "--porcelain")]
    (:out res)))
;; --- Comandos Espec√≠ficos ---

(defn task-org []
  (log "Iniciando sincroniza√ß√£o do ORG mode...")
  (let [org-dir (fs/file home "org")]
    (if (fs/exists? org-dir)
      (do
        (shell {:dir org-dir} "git pull")
        (shell {:dir org-dir} "git add --all")
        ;; continue: true impede que o script pare se n√£o houver nada para commitar
        (shell {:dir org-dir :continue true} "git commit -m \"Mensagem Padr√£o\"")
        (shell {:dir org-dir} "git push"))
      (err (str "Diret√≥rio " org-dir " n√£o encontrado!")))))

(defn task-mise []
  (log "Atualizando Mise...")
  (shell "mise upgrade"))

(defn task-doom []
  (log "Atualizando Doom Emacs...")
  ;; Assume que o bin√°rio doom est√° no PATH. Se n√£o estiver, use o caminho absoluto.
  (shell "doom sync -u --gc --rebuild --aot"))

(defn get-distro []
  "Tenta detectar se √© Arch ou Debian based lendo /etc/os-release"
  (if (fs/exists? "/etc/os-release")
    (let [content (slurp "/etc/os-release")]
      (cond
        (or (str/includes? content "ID=arch")
            (str/includes? content "ID_LIKE=arch")) :arch
        (or (str/includes? content "ID=debian")
            (str/includes? content "ID_LIKE=debian")
            (str/includes? content "ID=ubuntu")) :debian
        :else :unknown))
    :unknown))

(defn task-os []
  (log "Atualizando o Sistema Operacional...")
  (case (get-distro)
    :arch   (shell "sudo pacman -Syu")
    :debian (shell "sudo apt update && sudo apt upgrade -y")
    :unknown (err "N√£o foi poss√≠vel identificar se √© Arch ou Debian. Atualiza√ß√£o manual necess√°ria.")))

(defn task-config []
  (println "\nüõ†Ô∏è  Sincronizando Dotfiles...")

  (let [opts {:git-dir (str home "/.local/dotfiles/")
              :work-tree home}]

    ;; ALTERADO: Adicionamos :continue true.
    ;; Se o pull falhar (conflito), o script N√ÉO para.
    ;; Ele vai tentar rodar o status e salvar suas mudan√ßas locais mesmo assim.
    (println "‚¨áÔ∏è Tentando atualizar (git pull)...")
    (let [pull-res (git :pull (assoc opts :continue true))]
      (when (not= 0 (:exit pull-res))
        (println "‚ö†Ô∏è Falha no pull (provavelmente conflitos locais). Continuando para o commit...")))

    (let [status-out (git :status-porcelain opts)
          files-to-add (->> (str/split-lines status-out)
                            (map str/trim)
                            (filter #(re-find #"^[MD]" %)) ;; Modified ou Deleted
                            (map #(second (str/split % #"\s+" 2))))]

      (if (seq files-to-add)
        (do
          (git :add opts files-to-add)
          (git :commit opts "Update dotfiles via script")
          (git :push opts))
        (println "‚ú® Nada para commitar nos dotfiles."))))

    (println "‚úÖ Sincroniza√ß√£o finalizada."))

(defn task-all []
  (log "Executando TODAS as tarefas...")
  ;; Ordem solicitada: config, os, mise, doom, org
  (task-config)
  (task-os)
  (task-mise)
  (task-doom)
  (task-org))

(defn print-help []
  (println "Uso: synconfig [comando]")
  (println "Comandos dispon√≠veis: org, mise, doom, os, config, all"))

;; --- Main ---

(def command (first *command-line-args*))

(case command
  "org"    (task-org)
  "mise"   (task-mise)
  "doom"   (task-doom)
  "os"     (task-os)
  "config" (task-config)
  "all"    (task-all)
  (print-help))

